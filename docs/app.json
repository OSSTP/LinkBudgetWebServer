[{"name": "app.py", "content": "\n\nfrom Equation_Files import Equations\nimport Equation_Files.Equation_Constants as Constants\nimport os\nfrom datetime import datetime\nfrom rounding import round_1, round_2, round_3\nimport copy as cp\nfrom shiny import App, render, ui, reactive\nimport Parameter\nfrom param_dicts import all_params, info_params\nimport asyncio\nimport copy\nimport time\nfrom datetime import date\nimport numpy as np\nimport pandas as pd\n\n# create a reference to reset all_params to\ndefault_values = copy.deepcopy(all_params)\n\n# Create a reference copy of the original all_params\nOriginal_values = copy.deepcopy(all_params)\n\n# create a global variable to track when the last change was detected\nlast_change = time.time()\n\n# \"text-align: center\"\napp_ui = ui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n            ui.div({\"style\": \"text-align: center;\"},\n                   ui.h3(\"Enter Your Values Here\")),\n            ui.input_switch(\"tablemode\", \"Simple Table\", True),\n            ui.div({\"style\": \"color:#1d6bd1;font-weight: 900;\"},\n                   ui.h5(\"System\")\n                   ),\n\n            # create a tab for the System inputs\n\n            # ui.div(\n            #     # make bold to indicate that it is required\n            #     {\"style\": \"font-weight: bold;\"},\n            #     ui.input_numeric(\"a1\",\n            #                      \"Number of Satellites\",\n            #                      min=1,\n            #                      value=Original_values[\"System\"][\"Number of Satellites\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"a2\",\n                                 \"Altitude (km)\",\n                                 min=0,\n                                 value=Original_values[\"System\"][\"Altitude\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"a7\",\n                                 \"Frequency (GHz)\",\n                                 min=0,\n                                 value=Original_values[\"System\"][\"Frequency\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"a9\",\n                                 \"Allocated Bandwidth per Carrier (MHz)\",\n                                 min=0,\n                                 value=Original_values[\"System\"][\"Allocated Bandwidth Per Carrier\"].value)),\n            # ui.div(\n            #     # make bold to indicate that it is required\n            #     {\"style\": \"font-weight: bold;\"},\n            #     ui.input_numeric(\"a10\",\n            #                      \"ES Latitude (deg)\",\n            #                      value=Original_values[\"System\"][\"Latitude\"].value)),\n            # ui.div(\n            #     # make bold to indicate that it is required\n            #     {\"style\": \"font-weight: bold;\"},\n            #     ui.input_numeric(\"a11\",\n            #                      \"ES Longitude (deg)\",\n            #                      value=Original_values[\"System\"][\"Longitude\"].value)),\n            ui.div({\"style\": \"color:#1d6bd1;font-weight: 900;\"},\n                   ui.h5(\"Tx\")\n                   ),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"b1\",\n                                 \"Power Amp RF Output (W)\",\n                                 min=0,\n                                 value=Original_values[\"Tx\"][\"Power Amp RF Output (W)\"].value)),\n            # ui.div(\n            #     # make bold to indicate that it is required\n            #     {\"style\": \"font-weight: bold;\"},\n            #     ui.input_numeric(\"b3\",\n            #                      \"Tx Noise Power Ratio (dB)\",\n            #                      value=Original_values[\"Tx\"][\"Tx Noise Power Ratio\"].value)),\n            # ui.div(\n            #     # make bold to indicate that it is required\n            #     {\"style\": \"font-weight: bold;\"},\n            #     ui.input_numeric(\"b5\",\n            #                      \"Tx Cross-Pol Isolation (XPI) (dB)\",\n            #                      value=Original_values[\"Tx\"][\"Tx Cross-Pol Isolation (XPI)\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"b8\",\n                                 \"Tx Antenna Diameter (m)\",\n                                 min=0,\n                                 value=Original_values[\"Tx\"][\"Tx Antenna Diameter\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"b7\",\n                                 \"Tx Antenna Efficiency\",\n                                 value=Original_values[\"Tx\"][\"Tx Antenna Efficiency\"].value)),\n\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"b10\",\n                                 \"Feeder (Insertion) Loss (dB)\",\n                                 value=Original_values[\"Tx\"][\"Feeder (Insertion) Loss\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"b11\",\n                                 \"Polarization Mismatch (dB)\",\n                                 value=Original_values[\"Tx\"][\"Polarization Mismatch\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"b12\",\n                                 \"Pointing Error (degrees)\",\n                                 value=Original_values[\"Tx\"][\"Pointing Error\"].value)),\n            ui.div({\"style\": \"color:#1d6bd1;font-weight: 900;\"},\n                   ui.h5(\"Propagation\")\n                   ),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"c1\",\n                                 \"Elevation Angle (degrees)\",\n                                 value=Original_values[\"Propagation\"][\"Elevation Angle\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"c7\",\n                                 \"Atmospheric Gas Losses (dB)\",\n                                 value=Original_values[\"Propagation\"][\"Atmospheric Gas Losses\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"c8\",\n                                 \"Rain Fade (dB)\",\n                                 value=Original_values[\"Propagation\"][\"Rain Fade\"].value)),\n            ui.div({\"style\": \"color:#1d6bd1;font-weight: 900;\"},\n                   ui.h5(\"Rx\")\n                   ),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"d1\",\n                                 \"Rx Antenna Diameter (m)\",\n                                 min=0,\n                                 value=Original_values[\"Rx\"][\"Rx Antenna Diameter\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"d3\",\n                                 \"Rx Antenna Efficiency\",\n                                 value=Original_values[\"Rx\"][\"Rx Antenna Efficiency\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"d4\",\n                                 \"Rx Antenna Gain (dBi)\",\n                                 value=Original_values[\"Rx\"][\"Rx Antenna Gain\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"d5\",\n                                 \"Rx Pointing Error (degrees)\",\n                                 value=Original_values[\"Rx\"][\"Rx Pointing Error\"].value)),\n            # ui.div(\n            #     # make bold to indicate that it is required\n            #     {\"style\": \"font-weight: bold;\"},\n            #     ui.input_numeric(\"d7\",\n            #                      \"I - Rx XPI (dB)\",\n            #                      value=Original_values[\"Rx\"][\"I - Rx XPI\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"d8\",\n                                 \"Rx Antenna Temperature (K)\",\n                                 value=Original_values[\"Rx\"][\"Rx Antenna Temperature\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"d9\",\n                                 \"Rx LNA Noise Figure (dB)\",\n                                 value=Original_values[\"Rx\"][\"Rx LNA Noise Figure\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"d12\",\n                                 \"Rx Feed Operating Temperature (K)\",\n                                 value=Original_values[\"Rx\"][\"Rx Feed Operating Temperature\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"d13\",\n                                 \"Rx Feed and Input Filter Loss (dB)\",\n                                 value=Original_values[\"Rx\"][\"Rx Feed and Input Filter Loss\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"d14\",\n                                 \"Rx System Noise Temperature (K)\",\n                                 value=Original_values[\"Rx\"][\"Rx System Noise Temperature\"].value)),\n            ui.div({\"style\": \"color:#1d6bd1;font-weight: 900;\"},\n                   ui.h5(\"Link Performance\")\n                   ),\n            # Handle the Transmission page inputs\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_selectize(\"e1\",\n                                   \"Waveform\",\n                                   [\"DVB-S2X\", \"Other\"],\n                                   selected=Original_values[\"Link Performance\"][\"Waveform\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_selectize(\"e2\",\n                                   \"Modulation Scheme\",\n                                   [\"BPSK\", \"QPSK\", \"8PSK\", \"16APSK\",\n                                            \"32APSK\", \"64APSK\", \"128APSK\"],\n                                   selected=Original_values[\"Link Performance\"][\"Modulation Scheme\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"e3\",\n                                 \"Roll-off Factor\",\n                                 value=Original_values[\"Link Performance\"][\"Roll-off Factor\"].value)),\n            # ui.div(\n            #     # make bold to indicate that it is required\n            #     {\"style\": \"font-weight: bold;\"},\n            #     ui.input_numeric(\"e5\",\n            #                      \"Modulation bits/symbol (bits/sym)\",\n            #                      value=Original_values[\"Link Performance\"][\"Modulation bits/symbol\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"e6\",\n                                 \"Code Rate\",\n                                 value=Original_values[\"Link Performance\"][\"Code Rate\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"e7\",\n                                 \"Overhead\",\n                                 value=Original_values[\"Link Performance\"][\"Overhead\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"e8\",\n                                 \"Data Rate (Mbps)\",\n                                 value=Original_values[\"Link Performance\"][\"Data Rate\"].value)),\n            # ui.div(\n            #     # make bold to indicate that it is required\n            #     {\"style\": \"font-weight: bold;\"},\n            #     ui.input_numeric(\"e9\",\n            #                      \"Communications Efficiency\",\n            #                      value=Original_values[\"Link Performance\"][\"Communications Efficiency\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"e13\",\n                                 \"Required Es/No (dB/Hz)\",\n                                 value=Original_values[\"Link Performance\"][\"Required Es/No\"].value)),\n            ui.div(\n                # make bold to indicate that it is required\n                {\"style\": \"font-weight: bold;\"},\n                ui.input_numeric(\"e17\",\n                                 \"Modem Implementation Loss (dB)\",\n                                 value=Original_values[\"Link Performance\"][\"Modem Implementation Loss\"].value)),\n\n        ),\n        ui.panel_main(\n            ui.row(\n                ui.column(8,\n                          ui.output_data_frame(\"value_change\")),\n                # ui.column(5,\n                #           ui.output_text_verbatim(\"result\")),\n                ui.column(4,\n                          ui.div(\n                              # make bold to indicate that it is required\n                              {\"style\": \"text-align: center\"},\n                              ui.input_action_button(\"Calculate\",\n                                                     \"Calculate\")),\n                          ui.div(\n                              # make bold to indicate that it is required\n                              {\"style\": \"text-align: center;margin-top: 25px;\"},\n                              ui.download_button(\"Download\",\n                                                 \"Download\")))\n\n            )\n        )\n    )\n)\n\n\ndef server(input, output, session):\n\n    # update all of the system values to the params dictionary\n    def Update_vals():\n        # if the button is on, add only the required values\n        for tab in all_params:\n            # loop through each of the entry values in the tab\n            for entry in all_params[tab]:\n                # only add the value if it is required\n                if all_params[tab][entry].entry_type == \"input\":\n                    # some of the code breaks if the user input is an int and not a float,\n                    # convert any ints to floats\n                    if isinstance(input[all_params[tab][entry].ui_id](), int):\n                        # assign the integer converted to a float\n                        all_params[tab][entry].value = float(input[all_params[tab]\n                                                                   [entry].ui_id]())\n                    else:\n                        # assign the user input to each value in the dictionary\n                        all_params[tab][entry].value = input[all_params[tab]\n                                                             [entry].ui_id]()\n\n    # recalculate all of the values, except for the one that changed\n    def Recalculate(tab=\"\", father=[]):\n        # make sure all dependent values except for the one changed are set to none\n        clear_depends([tab, father[0]])\n\n        # Recalculate the tab that changed\n        Equations.Run_Equations(all_params, tab)\n\n        # loop through each of the entry values in the tab\n        for entry in [entry for entry in all_params[tab] if entry not in father]:\n\n            if all_params[tab][entry].entry_type == \"input\":\n                ui.update_numeric(id=all_params[tab][entry].ui_id,\n                                  value=all_params[tab][entry].value)\n\n        # Recalculate the dependent tabs\n        for tab_to_recalc in all_params[tab][father[0]].tab_depend:\n            # Equations.Run_Equations(all_params, tab_to_recalc)\n\n            for entry in all_params[tab_to_recalc].keys():\n                if all_params[tab_to_recalc][entry].entry_type == \"input\":\n                    # update their values as well\n                    ui.update_numeric(id=all_params[tab_to_recalc][entry].ui_id,\n                                      value=all_params[tab_to_recalc][entry].value)\n\n    # update the global values, used to detect user changes\n\n    def update_original_vals():\n        global Original_values\n        Original_values = copy.deepcopy(all_params)\n\n    # find any change in user inputs\n    def detect_change():\n        if not time_pass(time.time(), 0.3):\n            return None\n\n        for tab in all_params:\n            # loop through each of the entry values in the tab\n            for entry in all_params[tab]:\n\n                # check if the value is the same\n                if str(all_params[tab][entry].value) == str(Original_values[tab][entry].value):\n                    # if they are the same, check the next\n                    continue\n                else:\n                    # update the timeout\n                    update_last_change()\n                    # if they are not the same, return tab and value change\n                    return [tab, entry]\n        return None\n\n    # clear the dependencies of any change within the same tab\n\n    def clear_depends(change):\n        # # if the change has connections to other tabs clear them\n        # for tab_to_clear in all_params[change[0]][change[1]].tab_depend:\n        #     clear_tab(tab_to_clear)\n\n        # depends are values to set to none if we are recalculate a value\n        for depend in all_params[change[0]][change[1]].depend:\n            all_params[change[0]\n                       ][depend].value = default_values[change[0]][depend].value\n\n    # update last run\n    def update_last_change():\n        global last_change\n\n        last_change = time.time()\n\n    # calculate how much time has passed\n    def time_pass(current_time, elapse):\n        # load the global variable into the function\n        global last_change\n\n        # check if the difference exceeds the elapse\n        if current_time - last_change > elapse:\n            return True\n        else:\n            return False\n\n    # download the parameters as a csv if the user clicks download\n    @session.download(filename=lambda: f\"OSSTP-Link-Budget-{date.today().isoformat()}-{np.random.randint(100,999)}.csv\")\n    async def Download():\n        await asyncio.sleep(0.25)\n        yield \"Category, Parameter, Value, Units\\n\"\n        for tab in all_params:\n            # loop through each of the entry values in the tab\n            for entry in all_params[tab]:\n                yield f\"{tab}, {entry}, {all_params[tab][entry].value}, {all_params[tab][entry].unit}\\n\"\n\n    # create a connection to the button that ignores all of the dependent\n    # values and purely updates everything on the required values\n    @reactive.Effect\n    @reactive.event(input.Calculate)\n    def assurance_calculation():\n        # make sure that all of the values are recorded\n        Update_vals()\n\n        for tab in all_params:\n            # loop through each of the entry values in the tab\n            for entry in all_params[tab]:\n                # check if a user inputted value is none, if so raise a warning\n                if all_params[tab][entry].entry_type == \"input\" and all_params[tab][entry].value is None:\n                    m = ui.modal(\n                        f\"Info: {info_params[tab][entry]}\",\n                        title=f\"Please enter a value for {entry}\",\n                        easy_close=True,\n                        footer=None,\n                    )\n                    ui.modal_show(m)\n                    return None\n\n                if all_params[tab][entry].entry_type != \"input\":\n                    # if the function is not an input type, set its value to the default\n                    all_params[tab][entry].value = default_values[tab][entry].value\n        # calculate all of the values and update them\n        Equations.Run_All_Equations(all_params)\n\n        # now update the user input\n        for tab in all_params:\n            # loop through each of the entry values in the tab\n            for entry in all_params[tab]:\n                # only update the required values\n                if all_params[tab][entry].entry_type == \"input\":\n                    # make sure to update the time to block the code from automatically running\n                    update_last_change()\n                    ui.update_numeric(id=all_params[tab][entry].ui_id,\n                                      value=all_params[tab][entry].value)\n\n        ui.notification_show(\"Calculation Complete \\U0001F6F0\",\n                             duration=3)\n\n    @output\n    @render.data_frame\n    def value_change():\n        # make it react to recalculate button\n        input.Calculate()\n\n        # record the tablemode button\n        btn = input.tablemode()\n\n        # start by taking a local copy of all of the users input\n        Update_vals()\n        change = detect_change()\n        with reactive.isolate():\n            if change is not None:\n                Recalculate(change[0], [change[1]])\n        update_original_vals()\n        output_str = \"\"\n        output_table = {\n            \"Parameter\": [], \"Value\": [], \"Units\": []}\n\n        # only load the simple table if button true\n        if btn:\n\n            # generate a table output\n            for tab in all_params:\n                # output_str += tab + \"\\n\"\n                # loop through each of the entry values in the tab\n                for entry in all_params[tab]:\n                    # only visualize the required values\n                    if all_params[tab][entry].entry_type == \"input\":\n\n                        # add the data parameter\n                        output_table[\"Parameter\"].append(entry)\n                        # add the parameter value\n                        # if it is a float, round it\n                        if isinstance(all_params[tab][entry].value, float):\n                            # round all of them to 2 places except for wavelength\n\n                            output_table[\"Value\"].append(\n                                str(round(all_params[tab][entry].value, 3)))\n                        else:\n                            output_table[\"Value\"].append(\n                                str(all_params[tab][entry].value))\n                        # add the parameter unit\n                        output_table[\"Units\"].append(\n                            str(all_params[tab][entry].unit))\n        else:\n            # generate a table output\n            for tab in all_params:\n                # output_str += tab + \"\\n\"\n                # loop through each of the entry values in the tab\n                for entry in all_params[tab]:\n                    # add the data parameter\n                    output_table[\"Parameter\"].append(entry)\n                    # add the parameter value\n                    # if it is a float, round it\n                    if isinstance(all_params[tab][entry].value, float):\n                        output_table[\"Value\"].append(\n                            str(round(all_params[tab][entry].value, 3)))\n                    else:\n                        output_table[\"Value\"].append(\n                            str(all_params[tab][entry].value))\n                    # add the parameter unit\n                    output_table[\"Units\"].append(\n                        str(all_params[tab][entry].unit))\n\n        # convert the dictionary to a dataframe\n        output_table = pd.DataFrame(output_table)\n        return render.DataGrid(\n            output_table,\n            row_selection_mode='none',\n            height=1100,\n            width=\"100%\",\n            filters=False,\n        )\n\n\napp = App(app_ui, server)\n", "type": "text"}, {"name": "Parameter.py", "content": "class Parameter():\n    \"\"\"\n       Class representing one parameter in the gui and its characteristics\n\n        Attributes: \n            name: A string representing the name of the parameter.\n            unit: A string representing units of the parameter.\n            value: A float representing the value of the parameter.\n            entry_type: A string indicating if the parameter is an input\n                or calculated. This suggests whether the user should input\n                the value or let it be calculated.\n            user_inputed: A string indicating if the user inputed the value.\n    \"\"\"\n\n    def __init__(self, name, value, unit, entry_type, ui_id=None, depend=[], tab_depend=[]):\n        self.name = name\n        self.unit = unit\n        self.value = value\n        self.entry_type = entry_type\n        # Initially automatically assume that every input\n        # is inputed by the user since nothing has been\n        # calculated yet.\n        self.user_inputed = \"Yes\"\n        self.ui_id = ui_id\n        self.depend = depend\n        self.tab_depend = tab_depend\n", "type": "text"}, {"name": "Start Up Guide.md", "content": "# Start Up Guide - Instructions for running Link Budget Calculator Generation2\n\n\n## Downloading the Repository\n---\n\n### 1. Clone this repository\n1) Navigate to [the repository on Github](https://github.com/OSSTP/LinkBudgetCalculator)\n4) Click the green download Code button and then _Clone._ \n5) Set up a branch with your name if you plan on contributing to the respository by following [this tutorial](https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging).\n6) Make sure you pull from the main branch with `git pull origin main` so that you are using the most up-to-date software. If your terminal is responding with errors about branch merging, reference [this website](https://git-scm.com/search/results?search=merge)\n\n### 2. Install Dependencies\nFollow the \"Set-up Environment\" steps in the FCC-ELS [README.md](https://github.com/OSSTP/FCC-ELS/tree/main) and use the `requirements.txt` file in Generation2. \n\n## Running the Programs\n___\n\n### 1. Adjusting Input Parameters\n\n1) Open a new window in Command Prompt (Windows) or Terminal (MacOS/Linux).\n2) In Command Prompt, navigate to the folder which contains these scripts (../Generation2/)\n* Windows: _cd_ and _dir_ commands change and list directories, respectively\n* UNIX: _cd_ and _ls_ commands change and list directories, respectively\n3) In Command Prompt, run the _python_ command to open the gui:\n~~~\n$ python gui.py\n~~~\n4) Now, you can enter input parameters or correct the default input parameters as needed. Note that we suggest that you input values into the yellow boxes, and let the other white boxes be calculated. However, this is not required!\n\n***Note:*** If you don't understand what a variable is, click on the name to reveal its definition. \n\n### 2. Calculating the Link Budget\n1) Press the calculate button once you've filled in all the required parameters \n2) To download the values in a _csv_ file located in _../Generation2/_ , click the download button. The file will be named *Link_Budget_Calculations.csv*\n\n***Note:*** There are 3 key reasons, you may run into errors when trying to calculate values. See the _Help_ tab on the interface to understand these errors. \n", "type": "text"}, {"name": "param_dicts.py", "content": "from Parameter import Parameter\n\n\nsystem_params = {\n    # \"Number of Satellites\": Parameter(\"Number of Satellites\", None, \"satellites\", \"input\", \"a1\", []),\n    \"Altitude\": Parameter(\"Altitude\", None, \"km\", \"input\", \"a2\", [\"Orbital Radius\", \"Orbital Period\", \"Orbital Speed\"], [\"Propagation\", \"Tx\"]),\n    \"Orbital Radius\": Parameter(\"Orbital Radius\", None, \"km\", \"calculated\", \"a3\", [\"Altitude\", \"Orbital Period\", \"Orbital Speed\"], [\"Propagation\", \"Tx\"]),\n    \"Orbital Speed\": Parameter(\"Orbital Speed\", None, \"km/s\", \"calculated\", \"a4\", [\"Orbital Radius\", \"Altitude\", \"Orbital Period\"], [\"Propagation\", \"Tx\"]),\n    \"Orbital Period\": Parameter(\"Orbital Period\", \"\", \"hrs:mins:secs\", \"calculated\", \"a5\", [\"Orbital Radius\", \"Altitude\", \"Orbital Speed\"], [\"Propagation\", \"Tx\"]),\n    \"Radius of the earth\": Parameter(\"Radius of the Earth\", 6378.16, \"km\", \"calculated\", \"a6\", [], [\"Propagation\", \"Tx\"]),\n    \"Frequency\": Parameter(\"Frequency\", None, \"GHz\", \"input\", \"a7\", [\"Wavelength\"], [\"Propagation\", \"Rx\", \"Tx\"]),\n    \"Wavelength\": Parameter(\"Wavelength\", None, \"m\", \"calculated\", \"a8\", [\"Frequency\"], [\"Propagation\", \"Rx\", \"Tx\"]),\n    \"Allocated Bandwidth Per Carrier\": Parameter(\"Allocated Bandwidth Per Carrier\", None, \"MHz\", \"input\", \"a9\", [], [\"Link Performance\"]),\n    # \"Latitude\": Parameter(\"ES Latitude\", None, \"deg\", \"input\", \"a10\", [], [\"Propagation\"]),\n    # \"Longitude\": Parameter(\"ES Longitude\", None, \"deg\", \"input\", \"a11\", [], [\"Propagation\"]),\n    # \"Pressure\": Parameter(\"ES Pressure\", None, \"hPa\", \"calculated\", \"a12\", [], [\"Propagation\"]),\n}\n\n\ntx_params = {\n    \"Power Amp RF Output (W)\": Parameter(\"Power Amp RF Output (W)\", None, \"W\", \"input\", \"b1\", [\"Power Amp RF Output (dBW)\"], [\"Link Performance\"]),\n    \"Power Amp RF Output (dBW)\": Parameter(\"Power Amp RF Output (dBW)\", None, \"dBW\", \"calculated\", \"b2\", [\"Power Amp RF Output (W)\", \"I - Tx NPR\", \"Tx Noise Power Ratio\"], [\"Link Performance\"]),\n    # \"Tx Noise Power Ratio\": Parameter(\"Tx Noise Power Ratio\", None, \"dB\", \"calculated\", \"b3\", [\"3 dB Beamwidth\", \"I - Tx NPR\",  \"Power Amp RF Output (dBW)\"], [\"Link Performance\"]),\n    # \"I - Tx NPR\": Parameter(\"I - Tx NPR\", None, \"dB\", \"calculated\", \"b4\", [\"3 dB Beamwidth\", \"Tx Noise Power Ratio\", \"Power Amp RF Output (dBW)\"], [\"Link Performance\"]),\n    # \"Tx Cross-Pol Isolation (XPI)\": Parameter(\"Tx Cross-Pol Isolation (XPI)\", None, \"dB\", \"calculated\", \"b5\", [\"Power Amp RF Output (dBW)\", \"I - Tx XPI\"], [\"Link Performance\"]),\n    # \"I - Tx XPI\": Parameter(\"I - Tx XPI\", None, \"dB\", \"calculated\", \"b6\", [\"Tx Cross-Pol Isolation (XPI)\", \"Power Amp RF Output (dBW)\"], [\"Link Performance\"]),\n    \"Tx Antenna Efficiency\": Parameter(\"Tx Antenna Efficiency\", None, \"\", \"input\", \"b7\", [\"Tx Antenna Diameter\", \"Tx Antenna Gain\"]),\n    \"Tx Antenna Diameter\": Parameter(\"Tx Antenna Diameter\", None, \"m\", \"input\", 'b8', [\"3 dB Beamwidth\", \"Tx Antenna Efficiency\", \"Tx Antenna Gain\", \"3 dB Footprint Radius\"]),\n    \"Tx Antenna Gain\": Parameter(\"Tx Antenna Gain\", None, \"dBi\", \"calculated\", \"b9\", [\"Tx Antenna Diameter\", \"Tx Antenna Efficiency\"]),\n    \"Feeder (Insertion) Loss\": Parameter(\"Feeder (Insertion) Loss\", None, \"dB\", \"input\", \"b10\", [\"Tx ERP\", \"3 dB Beamwidth\", \"3 dB Footprint Radius\"], []),\n    \"Polarization Mismatch\": Parameter(\"Polarization Mismatch\", None, \"dB\", \"input\", \"b11\", [\"Tx ERP\", \"3 dB Beamwidth\", \"3 dB Footprint Radius\"], [\"Link Performance\"]),\n    \"Pointing Error\": Parameter(\"Pointing Error\", None, \"degrees\", \"input\", \"b12\", [\"Tx Pointing Loss\", \"3 dB Beamwidth\",  \"Tx ERP\", \"3 dB Footprint Radius\"]),\n    \"Tx Pointing Loss\": Parameter(\"Tx Pointing Loss\", None, \"dB\", \"calculated\", \"b13\", [\"Pointing Error\", \"3 dB Beamwidth\", \"Tx ERP\", \"3 dB Footprint Radius\"]),\n    \"Tx EIRP\": Parameter(\"Tx EIRP\", None, \"dBW\", \"calculated\", \"b14\", [\"Tx ERP\"]),\n    \"Tx ERP\": Parameter(\"Tx ERP\", None, \"dBW\", \"calculated\", \"b15\", [\"Tx EIRP\"]),\n    \"3 dB Beamwidth\": Parameter(\"3 dB Beamwidth\", None, \"degrees\", \"calculated\", \"b16\", [\"Tx Antenna Diameter\", \"3 dB Footprint Radius\", \"Pointing Error\", \"Tx Noise Power Ratio\", \"I - Tx NPR\"], [\"Link Performance\"]),\n    \"3 dB Footprint Radius\": Parameter(\"3 dB Footprint Radius\", None, \"km\", \"calculated\", \"b17\", [\"3 dB Beamwidth\"]),\n}\n\nprop_params = {\n    \"Elevation Angle\": Parameter(\"Elevation Angle\", None, \"degrees\", \"input\", \"c1\", [\"Path Length\", \"Beta\", \"Gamma\", \"Pass Duration\", \"Total Propagation Loss\"]),\n    \"Beta\": Parameter(\"Beta\", None, \"degrees\", \"calculated\", \"c2\", [\"Elevation Angle\", \"Gamma\", \"Pass Duration\"]),\n    \"Gamma\": Parameter(\"Gamma: Earth Internal Angle\", None, \"degrees\", \"calculated\", \"c3\", [\"Beta\", \"Elevation Angle\", \"Pass Duration\"], [\"Link Performance\"]),\n    \"Pass Duration\": Parameter(\"Pass Duration\", None, \"min\", \"calculated\", \"c4\", [\"Gamma\"], [\"Link Performance\"]),\n    \"Path Length\": Parameter(\"Path Length\", None, \"km\", \"calculated\", \"c5\", [\"Free Space Path Loss\"]),\n    \"Free Space Path Loss\": Parameter(\"Free Space Path Loss\", None, \"dB\", \"calculated\", \"c6\", [\"Path Length\", \"Total Propagation Loss\", ], [\"Link Performance\"]),\n    \"Atmospheric Gas Losses\": Parameter(\"Atmospheric Gas Losses\", None, \"dB\", \"input\", \"c7\", [\"Total Propagation Loss\", \"Free Space Path Loss\"], [\"Link Performance\"]),\n    \"Rain Fade\": Parameter(\"Rain Fade\", None, \"dB\", \"input\", \"c8\", [\"Total Propagation Loss\", \"Free Space Path Loss\"], [\"Link Performance\"]),\n    \"Total Propagation Loss\": Parameter(\"Total Propagation Loss\", None, \"dB\", \"calculated\", \"c9\", [\"Free Space Path Loss\", \"Free Space Path Loss\"], [\"Link Performance\"]),\n}\n\n\nrx_params = {\n    \"Rx Antenna Diameter\": Parameter(\"Rx Antenna Diameter\", None, \"m\", \"input\", \"d1\", [\"Rx Beamwidth\", \"Rx Antenna Gain\", \"Rx Antenna Efficiency\"], [\"Link Performance\"]),\n    \"Rx Beamwidth\": Parameter(\"Rx Beamwidth\", None, \"degrees\", \"calculated\", \"d2\", [\"Rx Antenna Diameter\", \"Rx Pointing Loss\", \"Rx Pointing Error\"], [\"Link Performance\"]),\n    \"Rx Antenna Efficiency\": Parameter(\"Rx Antenna Efficiency\", None, \"\", \"input\", \"d3\", [\"Rx Antenna Gain\", \"Rx Antenna Diameter\"], [\"Link Performance\"]),\n    \"Rx Antenna Gain\": Parameter(\"Rx Antenna Gain\", None, \"dBi\", \"input\", \"d4\", [\"Rx Antenna Efficiency\", \"Rx Antenna Diameter\", \"Rx Pointing Loss\", \"Rx G/T\", \"Rx Feed and Input Filter Loss\", \"Rx System Noise Temperature\"], [\"Link Performance\"]),\n    \"Rx Pointing Error\": Parameter(\"Rx Pointing Error\", None, \"degrees\", \"input\", \"d5\", [\"Rx Beamwidth\", \"Rx Pointing Loss\"], [\"Link Performance\"]),\n    \"Rx Pointing Loss\": Parameter(\"Rx Pointing Loss\", None, \"dB\", \"calculated\", \"d6\", [\"Rx Beamwidth\", \"Rx Pointing Error\", \"Rx Antenna Gain\", \"Rx G/T\", \"Rx Feed and Input Filter Loss\", \"Rx System Noise Temperature\"], [\"Link Performance\"]),\n    # \"I - Rx XPI\": Parameter(\"I - Rx XPI\", None, \"dB\", \"calculated\", \"d7\", [], [\"Link Performance\"]),\n    \"Rx Antenna Temperature\": Parameter(\"Rx Antenna Temperature\", None, \"K\", \"input\", \"d8\", [], [\"Link Performance\"]),\n    \"Rx LNA Noise Figure\": Parameter(\"Rx LNA Noise Figure\", None, \"dB\", \"input\", \"d9\", [\"Rx Noise Factor\", \"Rx LNA Noise Effective Temperature\"]),\n    \"Rx Noise Factor\": Parameter(\"Rx Noise Factor\", None, \"\", \"calculated\", \"d10\", [\"Rx LNA Noise Figure\"]),\n    \"Rx LNA Noise Effective Temperature\": Parameter(\"Rx LNA Noise Effective Temperature\", None, \"K\", \"calculated\", \"d11\", [\"Rx LNA Noise Figure\", \"Rx System Noise Temperature\", \"Rx Antenna Temperature\", \"Rx Feed and Input Filter Loss\", \"Rx Feed Operating Temperature\"], [\"Link Performance\"]),\n    \"Rx Feed Operating Temperature\": Parameter(\"Rx Feed Operating Temperature\", None, \"K\", \"input\", \"d12\", [\"Rx System Noise Temperature\", \"Rx Antenna Temperature\", \"Rx Feed and Input Filter Loss\", \"Rx LNA Noise Effective Temperature\"], [\"Link Performance\"]),\n    \"Rx Feed and Input Filter Loss\": Parameter(\"Rx Feed and Input Filter Loss\", None, \"dB\", \"input\", \"d13\", [\"Rx System Noise Temperature\", \"Rx Antenna Temperature\", \"Rx Feed Operating Temperature\", \"Rx LNA Noise Effective Temperature\"], [\"Link Performance\"]),\n    \"Rx System Noise Temperature\": Parameter(\"Rx System Noise Temperature\", None, \"K\", \"input\", \"d14\", [\"Rx Feed and Input Filter Loss\", \"Rx Antenna Temperature\", \"Rx Feed Operating Temperature\", \"Rx LNA Noise Effective Temperature\", \"Rx Antenna Gain\", \"Rx Pointing Loss\", \"Rx G/T\"], [\"Link Performance\"]),\n    \"Rx G/T\": Parameter(\"Rx G/T\", None, \"dB/K\", \"calculated\", \"d15\", [\"Rx Antenna Gain\", \"Rx Pointing Loss\", \"Rx Feed and Input Filter Loss\", \"Rx System Noise Temperature\"], [\"Link Performance\"]),\n}\n\n\nlink_params = {\n    \"Waveform\": Parameter(\"Waveform\", \"DVB-S2X\", \"\", \"input\", \"e1\"),\n    \"Modulation Scheme\": Parameter(\"Modulation Scheme\", \"BPSK\", \"\", \"input\", \"e2\"),\n    \"Roll-off Factor\": Parameter(\"Roll-off Factor\", None, \"\", \"input\", \"e3\", [\"Symbol Rate\"]),\n    \"Symbol Rate\": Parameter(\"Symbol Rate\", None, \"Msym/sec\", \"calculated\", \"e4\", [\"Roll-off Factor\", \"Data Rate\", \"Modulation bits/symbol\", \"Code Rate\", \"Overhead\", \"Required Es/No\", \"Required C/No\", \"N - Noise\"]),\n    \"Modulation bits/symbol\": Parameter(\"Modulation bits/symbol\", None, \"bits/sym\", \"calculated\", \"e5\", [\"Symbol Rate\", \"Code Rate\", \"Overhead\", \"Data Rate\"]),\n    \"Code Rate\": Parameter(\"Code Rate\", None, \"\", \"input\", \"e6\", [\"Symbol Rate\", \"Modulation bits/symbol\", \"Overhead\", \"Data Rate\"]),\n    \"Overhead\": Parameter(\"Overhead\", None, \"\", \"input\", \"e7\", [\"Symbol Rate\", \"Modulation bits/symbol\", \"Code Rate\", \"Data Rate\"]),\n    \"Data Rate\": Parameter(\"Data Rate\", None, \"Mbps\", \"input\", \"e8\", [\"Symbol Rate\", \"Modulation bits/symbol\", \"Code Rate\", \"Overhead\", \"Communications Efficiency\", \"Data Transfer Per Pass\", \"Spectral Efficiency\", \"Required Es/No\", \"Required Eb/No\"]),\n    # \"Communications Efficiency\": Parameter(\"Communications Efficiency\", None, \"\", \"calculated\", \"e9\", [\"Data Rate\", \"Data Transfer Per Pass\"]),\n    \"Data Transfer Per Pass\": Parameter(\"Data Transfer Per Pass\", None, \"kB\", \"calculated\", \"e10\", [\"Data Rate\", \"Communications Efficiency\"]),\n    \"Spectral Efficiency\": Parameter(\"Spectral Efficiency\", None, \"bps/Hz\", \"calculated\", \"e11\", [\"Data Rate\"]),\n    \"Required Eb/No\": Parameter(\"Required Eb/No\", None, \"dB\", \"calculated\", \"e12\", [\"Required Es/No\", \"Modulation bits/symbol\", \"Required C/No\", \"Data Rate\"]),\n    \"Required Es/No\": Parameter(\"Required Es/No\", None, \"dB/Hz\", \"input\", \"e13\", [\"Required Eb/No\",  \"Required C/No\"]),\n    \"Required C/No\": Parameter(\"Required C/No\", None, \"dB/Hz\", \"calculated\", \"e14\", [\"Margin\", \"Minimum Pr/No\", \"Required Es/No\", \"Symbol Rate\", \"Data Rate\", \"Required Eb/No\", \"Required C/N\"]),\n    \"Required C/N\": Parameter(\"Required C/N\", None, \"dB\", \"calculated\", \"e15\", [\"Required C/No\", \"Margin\", \"Actual C/N+I\"]),\n    \"Power in Front of Receiver\": Parameter(\"Power in Front of Receiver\", None, \"dB\", \"calculated\", \"e16\"),\n    \"Modem Implementation Loss\": Parameter(\"Modem Implementation Loss\", None, \"dB\", \"input\", \"e17\", [\"C/N+I\", \"Actual C/N+I\"]),\n    \"G_Tx + L_Tx + L_prop + G_Rx + L_Rx\": Parameter(\"G_Tx + L_Tx + L_prop + G_Rx + L_Rx\", None, \"dB\", \"calculated\", \"e18\", [\"link I - Rx XPI\", \"link I - Tx XPI\", \"link I - Tx NPR\", \"C - Carrier\"]),\n    \"C - Carrier\": Parameter(\"C - Carrier\", None, \"dBW\", \"calculated\", \"e19\", [\"G_Tx + L_Tx + L_prop + G_Rx + L_Rx\", \"N - Noise\", \"Actual C/N\", \"C/N+I\", \"link I - Rx XPI\", \"link I - Tx XPI\", \"link I - Tx NPR\"]),\n    \"N - Noise\": Parameter(\"N - Noise\", None, \"dBW\", \"calculated\", \"e20\", [\"Symbol Rate\", \"C - Carrier\", \"Actual C/N\", \"C/N+I\", \"link I - Rx XPI\", \"link I - Tx XPI\", \"link I - Tx NPR\"]),\n    # \"link I - Tx NPR\": Parameter(\"link I - Tx NPR\", None, \"dBW\", \"calculated\", \"e21\", [\"G_Tx + L_Tx + L_prop + G_Rx + L_Rx\", \"C/N+I\", \"C - Carrier\", \"N - Noise\"]),\n    # \"link I - Tx XPI\": Parameter(\"link I - Tx XPI\", None, \"dBW\", \"calculated\", \"e22\", [\"G_Tx + L_Tx + L_prop + G_Rx + L_Rx\", \"C/N+I\", \"C - Carrier\", \"N - Noise\"]),\n    # \"link I - Rx XPI\": Parameter(\"link I - Rx XPI\", None, \"dBW\", \"calculated\", \"e23\", [\"G_Tx + L_Tx + L_prop + G_Rx + L_Rx\", \"C/N+I\", \"C - Carrier\", \"N - Noise\"]),\n    \"Actual C/No\": Parameter(\"Actual C/No\", None, \"dB/Hz\", \"calculated\", \"e24\", [\"Actual C/N\"]),\n    \"Actual C/N\": Parameter(\"Actual C/N\", None, \"dB\", \"calculated\", \"e25\", [\"C - Carrier\", \"N - Noise\", \"Actual C/No\"]),\n    \"C/N+I\": Parameter(\"C/N+I\", None, \"dB\", \"calculated\", \"e26\", [\"C - Carrier\", \"N - Noise\", \"Actual C/N+I\", \"Modem Implementation Loss\"]),\n    \"Actual C/N+I\": Parameter(\"Actual C/N+I\", None, \"dB\", \"calculated\", \"e27\", [\"Modem Implementation Loss\", \"C/N+I\", \"Required C/N\", \"Margin\"]),\n    \"Margin\": Parameter(\"Margin\", None, \"dB\", \"calculated\", \"e28\", [\"Actual C/N+I\", \"Required C/N\", \"Minimum Pr/No\", \"Required C/No\"]),\n    \"Minimum Pr/No\": Parameter(\"Minimum Pr/No\", None, \"dB-Hz\", \"calculated\", \"e29\", [\"Required C/No\", \"Margin\"]),\n}\n\n\nall_params = {\"System\": system_params, \"Tx\": tx_params, \"Propagation\": prop_params,\n              \"Rx\": rx_params, \"Link Performance\": link_params}\n\nsystem_text = {\n    \"Number of Satellites\": \"The number of satellites in the swarm or constellation\",\n    \"Altitude\": \"Satellite's distance above sea level\",\n    \"Orbital Radius\": \"Sum of the earth's radius and satellite\u2019s altitude\",\n    \"Orbital Speed\": \"Rate at which a satellite is traveling \\nCalculated with the following equation: \\n s = sqrt(G*M/R) \\nwhere G is the universal gravitational constant (N kg^-2 m^2), \\nM is the mass of the Earth (kg), \\nand R is the satellite's orbital radius (km).\",\n    \"Orbital Period\": \"Time, measured in seconds, for the satellite to complete one orbit around the Earth\",\n    \"Frequency\": \"Number of cycles of a wave per second for a given signal\",\n    \"Wavelength\": \"Distance between two successive crests or troughs of a wave\",\n    \"Allocated Bandwidth Per Carrier\": \"Bandwidth is the chunk of electromagnetic spectrum, or a 'range of frequencies' that the link is assigned to.\",\n    \"ES Latitude\": \"Latitude of Earth Station in degrees\",\n    \"ES Longitude\": \"Longitude of Earth Station in degrees\",\n    \"ES Pressure\": \"Average Yearly Pressure of the Earth Station in hPa - see ITU P.835\"\n}\n\ntx_text = {\n    \"Power Amp RF Output (W)\": \"Power of the signal, after amplification, that will be transmitted \\n\\nA power amplifier takes a low-power RF signal, \\nalready with the data encoding and modulation and at the desired frequency, \\nand boosts its signal strength to a level necessary for the design.\",\n\n    \"Power Amp RF Output (dBW)\": \"Power of the signal being transmitted in units of dBW, as opposed to Watts (W) \\n\\nOne decibel watt is equal to 10log(Power/1W)\",\n\n    \"Tx Noise Power Ratio\": \"Ratio of the power of background noise to the power of the signal \\n\\nRepresents how many dB the noise is from the intended power \\nThere is always inherent baseline noise due to non-ideal amplifiers.\",\n\n    \"I - Tx NPR\": \"Interference in the transmitted signal due to the inherent noise in the power amplifier \\n\\nFunction of the Power Amplifier RF Output and the Noise Power Ratio of the transmitter \\n\\nEx. PA RF Output Power = 10 dBW \\nNPR of the device = 19 dB \\n=> interference from NPR = -9 dBW.\",\n\n    \"Tx Cross-Pol Isolation (XPI)\": \"XPI stands for cross-polarization isolation, and is caused by depolarizations of waves that can lead to mutual interference of two links. Specifically, it is the ratio of the cross-polarized signal component from one transmitted polarization to the copolarized signal component for the orthogonal transmitted polarization. The two signal components that determine cross-polarization isolation are received on the same polarization. Cross polarization isolation is the quantity that limits the performance of dual-polarized communication systems.\",\n\n    \"I - Tx XPI\": \"I-Tx XPI is interference in the signal due to cross-polarization isolation and is a function of the Power Amplifier RF output and the Cross Polarization Isolation of the transmitter.\",\n\n    \"Tx Antenna Efficiency\": \"Antenna efficiency of an antenna is a ratio of the power delivered to the antenna relative to the power radiated from the antenna.\",\n\n    \"Tx Antenna Diameter\": \"The antenna diameter impacts the usable bandwidth of the antenna. The bigger the diameter, the bigger the effective bandwidth. \",\n\n    \"Tx Antenna Gain\": \"Antenna gain is the ratio of the power radiated (or received) per unit solid angle by an antenna in a given direction to that of an isotropic antenna fed with the same power. An isotropic antenna is a theoretical antenna that has an efficiency of 100% and radiates power equally in all directions, so it has a gain of 1 dB.\",\n\n    \"Feeder (Insertion) Loss\": \"In between the power amplifier and the antenna is a feeder, which connects the two together. Feeders, if ideal, would transfer the power between the PA and the antenna without any loss; however, in the real world a loss occurs as the power moves through the feeder.\",\n\n    \"Polarization Mismatch\": \"The loss in signal due to a mismatch in polarizations between the transmit and receive antennas.  Examples: Tx and Rx both right hand circularly polarized, mismatch=0dB.  Tx circularly polarized, Rx vertically polarized, mismatch=3dB.\",\n\n    \"Pointing Error\": \"The error due to the angular separation between the intended direction of propagation and the actual direction. Ideally there would be no error, but it is virtually impossible to achieve a perfect alignment between the antenna of the ground station and the satellite due to the satellite\u2019s fast movements.\",\n\n    \"Tx Pointing Loss\": \"Pointing loss is due to pointing error and is a function of pointing error and the receiver\u2019s beamwidth.\",\n\n    \"Tx EIRP\": \"Effective Isotropic Radiated Power (EIRP) measures a transmitter's performance by combining the transmitted power emitted and the antenna gain.  The EIRP of an antenna system is generally defined as : \\n EIRP = P + G - L \\n Where P is the transmitter output power, G is the gain of the transmitting antenna, and L is the signal attenuation in the feed between the transmitter and antenna. \\n (Flat Panel Antennas for Modern LEO Constellations)\",\n\n    \"Tx ERP\": \"ERP is essentially the same as EIRP except that ERP compares the actual antenna to a half-wave dipole antenna, while EIRP compares it to a theoretical isotropic antenna. Therefor ERP(dB) = EIRP(dB) - 2.15.\",\n\n    \"3 dB Beamwidth\": \"The beamwidth is the angle defined by a given decrease in gain relative to the peak gain. The 3 dB beamwidth corresponds to the angle over which the gain falls to half its maximum value.\",\n\n    \"3 dB Footprint Radius\": \"A 3 dB footprint is the portion of the Earth's surface over which the satellite antenna delivers power within 3 dB beamwidth.\",\n}\n\nprop_text = {\n    \"Elevation Angle\": \"Elevation angle is the vertical angle formed between the direction of travel of an electromagnetic wave radiated from an earth station antenna pointing directly toward a satellite and the horizontal.\",\n    \"Beta\": \"Intermediate angle used for calculations. Beta is the angle formed between the satellite to the center of the Earth and from the satellite to the ground station.\",\n    \"Gamma\": \"Intermediate angle used for calculations. Gamma = 90 - Elevation Angle - Beta.\",\n    \"Pass Duration\": \"The period in which a satellite or other spacecraft is above the local horizon and available for radio communication with the ground station.\",\n    \"Path Length\": \"The path length is the distance between a ground station and a satellite in orbit.\",\n    \"Free Space Path Loss\": \"Free Space Path Loss is a type of propagation loss that represents the ratio of the received power and transmitted powers in a link between two isotropic antennas. It doesn\u2019t refer to attenuation of signal, but to its spreading through space.\",\n    \"Atmospheric Gas Losses\": \"Atmospheric Gas Loss is a type of propagation loss due to gaseous attenuation. Uncondensed water vapour and oxygen can be strongly absorptive of radio signals, especially at millimetre-wave frequencies and higher (tens to hundred of GHz_. This is due to the existence of absorption lines in the elements composing atmospheric gases, or bands of frequencies where these games naturally absorb photon energy. This occurs at the resonance frequencies of the molecules themselves.\",\n    \"Rain Fade\": \"Rain Fade is a type of propagation loss due to the absorption of a microwave by atmospheric rain, snow or ice, which are especially prevalent at frequencies above 11 GHz. It also refers to the degradation of a signal caused by the electromagnetic interference of the leading edge of a storm front\",\n    \"Total Propagation Loss\": \"Total propagation loss is the total amount of power in a signal that is lost during a signal\u2019s propagation.\",\n}\n\nrx_text = {\n    \"Rx Antenna Diameter\": \"Diameter of the Antenna dish\",\n    \"Rx Beamwidth\": \"Beamwidth is the angle defined by a given decrease in gain relative to the peak gain. For example, the 3 dB beamwidth corresponds to the angle over which the gain falls to half its maximum value.\",\n    \"Rx Antenna Efficiency\": \"Antenna Efficiency is the ratio of the power delivered to an antenna relative to the power radiated from the antenna. A high efficiency antenna has most of the power present at the antenna's input radiated away. A low efficiency antenna has most of the power absorbed as losses within the antenna, or reflected away due to impedance mismatch.\",\n    \"Rx Antenna Gain\": \"Antenna gain is the ratio of the power radiated (or received) per unit solid angle by an antenna in a given direction to that of an isotropic antenna fed with the same power. An isotropic antenna is a theoretical antenna that has an efficiency of 100% and radiates power equally in all directions, so it has a gain of 1 dB.\",\n    \"Rx Pointing Error\": \"The error due to the angular separation between the intended direction of propagation and the actual direction. Ideally there would be no error, but it is virtually impossible to achieve a perfect alignment between the antenna of the ground station and the satellite due to the satellite\u2019s fast movements.\",\n    \"Rx Pointing Loss\": \"Pointing loss is due to pointing error and is a function of pointing error and the receiver\u2019s beamwidth.\",\n    \"I - Rx XPI\": \"XPI stands for cross-polarization isolation, and is caused by depolarizations of waves that can lead to mutual interference of two links. Specifically, it is the ratio of the cross-polarized signal component from one transmitted polarization to the copolarized signal component for the orthogonal transmitted polarization. The two signal components that determine cross-polarization isolation are received on the same polarization. Cross polarization isolation is the quantity that limits the performance of dual-polarized communication systems.\",\n    \"Rx Antenna Temperature\": \"Antenna temperature is the noise temperature of the antenna. The antenna noise temperature is determined by the background radiation in the antenna\u2019s given environment, i.e. the sky or the ground. The receiver noise temperature comes from the components that have dissipative losses, electronic noises, and reflection losses that generate noise.\",\n    \"Rx LNA Noise Figure\": \"The LNA Noise Figure can help determine the efficiency of a low noise amplifier (LNA) and is a key measurement of the performance of an RF receiver.\",\n    \"Rx Noise Factor\": \"The Rx Noise Factor can help determine the efficiencty of a low noise amplifier (LNA) and is a key measurement of the performance of an RF receiver.\",\n    \"Rx LNA Noise Effective Temperature\": \"The LNA Noise Effective Temperature refers to the effective input of the low noise amplifier (LNA).\",\n    \"Rx Feed Operating Temperature\": \"NEED DEFINITION HERE\",\n    \"Rx Feed and Input Filter Loss\": \"In between the power amplifier and the antenna is a feeder, which connects the two together. Feeders, if ideal, would transfer the power between the PA and the antenna without any loss; however, in the real world a loss occurs as the power moves through the feeder.\",\n    \"Rx System Noise Temperature\": \"The system noise temperature is all of the noise in the system added up. This includes the antenna temperature, the feed and input filter loss,  the Rx feed operating temperature, and the Rx LNA noise effective temperature.\",\n    \"Rx G/T\": \"The system noise temperature is all of the noise in the system added up. This includes the antenna temperature, the feed and input filter loss,  the Rx feed operating temperature, and the Rx LNA noise effective temperature.\",\n}\n\nlink_text = {\n    \"Roll-off Factor\": \"Roll-off Factor is a factor in spectral efficiency, or how much capacity one can squeeze into a particular band of spectrum. When a satellite signal is filtered, or masked, the \u2018edges\u2019 of the signal drops off and is not used for transmission. This drop off is known as Roll-off Factor (ROF). A lower ROF means that more of the signal can be used for transmission.\",\n    \"Symbol Rate\": \"Modulation is when a transmitter uses changes in phase, magnitude, or frequency to represent either analog or digital information. Modulation makes it so that a bit, or group of bits of information are mapped to a particular sate of the carrier wave. i.e.  different states of the carrier are represented in unique combinations of phase, frequency and magnitude. The state of the carrier is called a symbol.\",\n    \"Modulation bits/symbol\": \"Symbol Rate is the number of symbol changes, waveform changes, or signaling events per second made to the signal. Each symbol can represent or convey one or several bits of data. In other words, symbol rate is the rate at which the carrier changes 'state.'\",\n    \"Code Rate\": \"Code rate is the portion of the data-stream that is useful (non-redundant). Code rate is based on the number of bits entering the encoder divided by the number leaving it.\",\n    \"Overhead\": \"Overhead is the number of bits, communicated for a message, that do not represent the data bits of the message. Overhead bits are used for purposes such as error checking and marking the start and end of characters and packets.\",\n    \"Data Rate\": \"The data rate of the system is how fast information is transmitted in terms of megabits per second.\",\n    \"Spectral Efficiency\": \"Spectral efficiency is a channels ability to carry information given fixed bandwidth. More formally, it is the information rate that can be transmitted over a given bandwidth in a specific communication system. It is a measure of how efficiently a limited frequency spectrum is utilized by the physical layer protocol.\",\n    \"Required Es/No\": \"Es/No is the energy per symbol to noise power spectral density ratio. Es is the signal energy associated with each symbol. No is the noise spectral density, the noise power in a 1 Hz bandwidth.\",\n    \"Required C/No\": \"C/No is the carrier to noise density ratio. It is the ratio of the carrier power, C, to the noise power density, No. It determines whether a receiver can lock on to the carrier and if the information encoded in the signal can be retrieved, given the amount of noise present in the received signal.\",\n    \"Required C/N\": \"Carrier to noise ratio is a signal-to-noise ratio of a modulated signal. In simple terms, it is a measure of the received carrier strength in relation to the strength of the noise received.\",\n    \"Modem Implementation Loss\": \"e.g. detector efficiency\",\n    \"G_Tx + L_Tx + L_prop + G_Rx + L_Rx\": \"All gains and losses added together.\",\n    \"C - Carrier\": \"carrier power\",\n    \"N - Noise\": \"noise power\",\n    \"link I - Tx NPR\": \"same as transmitter NPR with gains and losses added\",\n    \"link I - Tx XPI\": \"same as transmitter XPI with gains and losses added\",\n    \"link I - Rx XPI\": \"same as receiver XPI with gains and losses added\",\n    \"C/N\": \"carrier power to noise power ratio. Note that C/N is the same thing as Signal-to-Noise ratio (SNR).\",\n    \"C/N+I\": \"carrier power to noise power ratio with intercference added\",\n    \"Actual C/N+I\": \"difference between carrier power to noise power ratio with interference added and detector efficiency subtracted\",\n    \"Margin\": \"The difference between the signal level received and the signal needed for good reception (i.e., receiver sensitivity).\",\n}\n\ninfo_params = {\"System\": system_text, \"Tx\": tx_text, \"Propagation\": prop_text,\n               \"Rx\": rx_text, \"Link Performance\": link_text}\n", "type": "text"}, {"name": "requirements.txt", "content": "matplotlib==3.5.2\nscipy==1.9.3\nnumpy==1.23.5\npandas==1.5.2\nJinja2==3.1.2", "type": "text"}, {"name": "rounding.py", "content": "\"\"\"\nThis module contains three lists that each indicate a number\nthat the values should be rounded to. These lists are utilized\nin interface.py in the grab_and_update_entries() function.\n\"\"\"\n\n# All of the parameters in this list will be rounded to one digit.\nround_1 = [\"Orbital Period\", \"Altitude\", \"Power Amp RF Output (dBW)\", \"Power Amp RF Output (W)\",  \"I - Tx NPR\", \"Tx Noise Power Ratio\", \"Tx Cross-Pol Isolation (XPI)\", \"Rx Feed Operating Temperature\", \"I - Tx XPI\", \"Pass Duration\", \"Data Transfer Per Pass\", \"Elevation Angle\", \"I - Rx XPI\", \"Roll-off Factor\", \"Modulation bits/symbol\", \"Overhead\"]\n\n# All of the parameters in this list will be rounded to two digits.\nround_2 = [\"Orbital Radius\", \"Orbital Speed\", \"Free Space Path Loss\", \"Path Length\", \"Total Propagation Loss\", \"Rain Fade\", \"Atmospheric Gas Losses\", \"Tx Antenna Efficiency\", \"3 dB Beamwidth\", \"Rx G/T\", \"Rx Antenna Gain\", \"Rx Pointing Loss\", \"Symbol Rate\",  \"Spectral Efficiency\", \"Required C/No\", \"Required C/N\", \"G_Tx + L_Tx + L_prop + G_Rx + L_Rx\", \"C - Carrier\", \"N - Noise\", \"link I - Tx NPR\", \"link I - Tx XPI\", \"link I - Rx XPI\", \"Actual C/N\", \"C/N+I\", \"Actual C/N+I\", \"Margin\", \"Tx Pointing Loss\", \"Pointing Error\", \"Tx Antenna Diameter\", \"3 dB Footprint Radius\", \"Tx EIRP\", \"Feeder (Insertion) Loss\", \"Tx ERP\", \"Rx Antenna Efficiency\", \"Rx Antenna Diameter\", \"Rx Beamwidth\", \"Rx Pointing Error\", \"Rx LNA Noise Effective Temperature\", \"Rx LNA Noise Figure\", \"Rx System Noise Temperature\", \"Rx Antenna Temperature\", \"Rx Feed and Input Filter Loss\", \"Code Rate\", \"Beta\", \"Gamma\", \"Communications Efficiency\", \"Required Es/No\", \"Modem Implementation Loss\", \"Wavelength\", \"Frequency\", \"Minimum Pr/No\", \"Actual C/No\", \"Rx Noise Factor\", \"Required Eb/No\", \"Allocated Bandwidth Per Carrier\", \"Tx Antenna Gain\", \"Latitude\", \"Longitude\", \"Pressure\",\"Power in Front of Receiver\",\"Polarization Mismatch\"]\n\n# All of the parameters in this list will be rounded to three digits.\nround_3 = [\"Data Rate\", \"Spectral Efficiency\"]\n\n", "type": "text"}, {"name": "Equation_Files/Equation_Constants.py", "content": "\"\"\"\nThis module contains constants that are used throughout different calculations.\n\"\"\"\n\n# define constants for all equations\nc = 2.99792458*(10**8)              # speed of light m/s\nG = 6.67430 * 1e-11         # Universal gravitational constant in m^3 kg^-1 s^-2\nM_earth = 5.9722 * 1e24     # Mass of the earth in kg\nr_E = 6378.145              # radius of Earth in km\n", "type": "text"}, {"name": "Equation_Files/Equations.py", "content": "from Equation_Files.System_Equations import Calculate_System\nfrom Equation_Files.Transmitter_Equations import Calculate_Transmitter\nfrom Equation_Files.Propagation_Equations import Calculate_Propagation\nfrom Equation_Files.Receiver_Equations import Calculate_Receiver\nfrom Equation_Files.Link_Equations import Calculate_Link\n\n\n# ----------------------------#\n\ndef Run_Equations(parameters, tab_name):\n    \"\"\"\n    Runs the calculations for different tabs as needed.\n\n    Args: \n        parameters: A dictionary of all parameter inputs we currently\n            have for the tab.\n        tabName: A string representing the name of the tab.\n    \"\"\"\n\n    system = Calculate_System()\n    transmitter = Calculate_Transmitter()\n    propagation = Calculate_Propagation()\n    receiver = Calculate_Receiver()\n    link = Calculate_Link()\n\n    if (tab_name == \"System\"):\n        parameters = system.runSystem(parameters)\n\n    if (tab_name == \"Tx\"):\n        parameters = transmitter.runTransmitter(parameters)\n\n    if (tab_name == \"Propagation\"):\n        parameters = propagation.runPropagation(parameters)\n\n    if (tab_name == \"Rx\"):\n        parameters = receiver.runReceiver(parameters)\n\n    if (tab_name == \"Link Performance\"):\n        parameters = link.runLink(parameters)\n\n\ndef Run_All_Equations(parameters):\n    \"\"\"\n    Runs all the calculations\n\n    Args: \n        parameters: A dictionary of all parameter inputs we currently\n            have for the tab.\n        tabName: A string representing the name of the tab.\n    \"\"\"\n\n    system = Calculate_System()\n    transmitter = Calculate_Transmitter()\n    propagation = Calculate_Propagation()\n    receiver = Calculate_Receiver()\n    link = Calculate_Link()\n\n    system.runSystem(parameters)\n\n    transmitter.runTransmitter(parameters)\n\n    propagation.runPropagation(parameters)\n\n    receiver.runReceiver(parameters)\n\n    link.runLink(parameters)\n", "type": "text"}, {"name": "Equation_Files/Link_Equations.py", "content": "import math\n\n\nclass Calculate_Link():\n\n    # ----- Calculation Functions -----#\n\n    def RollOff(self, symbolRate, allocBand):\n        # backtracked from SymbolRate\n        rollOff = allocBand/symbolRate-1\n        return rollOff\n\n    def AllocBand(self, symbolRate, rollOff):\n        # backtracked from SymbolRate\n        allocBand = symbolRate*(1+rollOff)\n        return allocBand\n\n    def AllocBand2(self, spectralEfficiency, dataRate):\n        # backtracked from SpectralEfficiency\n        allocBand = dataRate/spectralEfficiency\n        return allocBand\n\n    def AllocBand3(self, requiredC_N, requiredC_No):\n        # backtracked from RequiredC_N\n        allocBand = math.pow(10, (requiredC_No-60-requiredC_N)/10)\n        return allocBand\n\n    def AllocBand4(self, actualC_No, actualC_N):\n        # backtracked from ActualC_N0\n        allocBand = math.pow(10, (actualC_No-60-actualC_N)/10)\n        return allocBand\n\n    def SymbolRate(self, allocBand, rollOff):\n        symbolRate = allocBand/(1+rollOff)\n        return symbolRate\n\n    def SymbolRate2(self, dataRate, modBits, codeRate, overhead):\n        # backtracked from DataRate\n        symbolRate = dataRate/(modBits * codeRate * (1-overhead))\n        return symbolRate\n\n    def SymbolRate3(self, requiredC_No, requiredEs_No):\n        # backtracked from RequiredC_No\n        symbolRate = math.pow(10, (requiredC_No - 60 - requiredEs_No)/10)\n        return symbolRate\n\n    def SymbolRate4(self, noise, rxSystemNoiseTemp):\n        # backtracked from Noise\n        symbolRate = math.pow(\n            10, (noise+228.6 - 10*math.log10(rxSystemNoiseTemp))/10)/1000000\n        return symbolRate\n\n    def ModBits(self, dataRate, symbolRate, codeRate, overhead):\n        # backtracked from DataRate\n        modBits = dataRate/(symbolRate * codeRate * (1-overhead))\n        return modBits\n\n    def ModBits2(self, modulationScheme):\n        if modulationScheme == \"BPSK\":\n            return 1.0\n        elif modulationScheme == \"QPSK\":\n            return 2.0\n        elif modulationScheme == \"8PSK\":\n            return 3.0\n        elif modulationScheme == \"16APSK\":\n            return 4.0\n        elif modulationScheme == \"32APSK\":\n            return 5.0\n        elif modulationScheme == \"64APSK\":\n            return 6.0\n        elif modulationScheme == \"128APSK\":\n            return 7.0\n\n    def ModBits3(self, requiredEb_No, requiredEs_No):\n        # backtracked from requiredEb_No\n        modBits = math.pow(10, ((requiredEs_No - requiredEb_No)/10))\n        return modBits\n\n    def CodeRate(self, dataRate, symbolRate, modBits, overhead):\n        # backtracked from DataRate\n        codeRate = dataRate/(symbolRate * modBits * (1-overhead))\n        return codeRate\n\n    def Overhead(self, dataRate, symbolRate, modBits, codeRate):\n        # backtracked from DataRate\n        overhead = -dataRate/(symbolRate * modBits * codeRate)+1\n        return overhead\n\n    def DataRate(self, symbolRate, modBits, codeRate, overhead):\n        dataRate = symbolRate * modBits * codeRate * (1-overhead)\n        return dataRate\n\n    def DataRate2(self, dataTransfer, communicationsEfficiency, passDuration):\n        # backtracked from dataTransfer\n        dataRate = dataTransfer / \\\n            (communicationsEfficiency*passDuration*60*math.pow(10, 6)/8000)\n        return dataRate\n\n    def DataRate3(self, spectralEfficiency, allocBand):\n        # backtracked from SpectralEfficiency\n        dataRate = spectralEfficiency*allocBand\n        return dataRate\n\n    def DataRate4(self, requiredC_No, requiredEb_No):\n        dataRate = math.pow(10, (requiredC_No - requiredEb_No)/10) / 1e6\n        return dataRate\n\n    def CommunicationsEfficiency(self, dataTransfer, dataRate, passDuration):\n        # backtracked from DataTransfer\n        communicationsEfficiency = dataTransfer / \\\n            (dataRate*passDuration*60*math.pow(10, 6)/8000)\n        return communicationsEfficiency\n\n    def DataTransfer(self, dataRate, communicationsEfficiency, passDuration):\n        dataTransfer = dataRate*communicationsEfficiency * \\\n            passDuration*60*math.pow(10, 6)/8000\n        # multiply by 10^9 to convert from mbps to bps\n        return dataTransfer\n\n    def SpectralEfficiency(self, dataRate, allocBand):\n        spectralEfficiency = dataRate / allocBand\n        return spectralEfficiency\n\n    def WaveformOutputs(self, requiredEs_No, modulationScheme):\n\n        esNo_lookup = [-2.35, -1.24, -0.30, 1.00, 2.23, 6.20, 6.42, 5.50, 6.62, 7.91, 9.35, 10.69, 10.98, 8.97, 10.21,\n                       11.03, 11.61, 12.89, 13.13, 12.73, 13.64, 14.28, 15.69, 16.05, 14.81, 15.47, 15.87, 16.55, 17.73, 18.53]\n        specEffic_lookup = [0.49, 0.656, 0.789, 0.989, 1.188, 1.766, 1.789, 1.78, 1.981, 2.228, 2.479, 2.646, 2.679, 2.637,\n                            2.967, 3.166, 3.3, 3.523, 3.567, 3.703, 3.952, 4.119, 4.398, 4.453, 4.339, 4.603, 4.734, 4.933, 5.163, 5.356]\n        codeRate_lookup = [0.25, 0.33, 0.40, 0.50, 0.60, 0.89, 0.90, 0.60, 0.67, 0.75, 0.83, 0.89, 0.90, 0.67,\n                           0.75, 0.80, 0.83, 0.89, 0.90, 0.75, 0.80, 0.83, 0.89, 0.90, 0.73, 0.78, 0.80, 0.83, 0.75, 0.78]\n\n        modScheme_lookup = [\"QPSK\", \"QPSK\", \"QPSK\", \"QPSK\", \"QPSK\", \"QPSK\", \"QPSK\", \"8PSK\", \"8PSK\", \"8PSK\", \"8PSK\", \"8PSK\", \"8PSK\", \"16APSK\", \"16APSK\",\n                            \"16APSK\", \"16APSK\", \"16APSK\", \"16APSK\", \"32APSK\", \"32APSK\", \"32APSK\", \"32APSK\", \"32APSK\", \"64APSK\", \"64APSK\", \"64APSK\", \"64APSK\", \"128APSK\", \"128APSK\"]\n\n        # based on index of Esno, map each parameter to a corresponding index\n        index = min(range(len(esNo_lookup)), key=lambda i: abs(\n            esNo_lookup[i]-requiredEs_No))\n\n        # only set modulation scheme if it is currently blank\n        if modulationScheme == \"    \":\n            modulationScheme = modScheme_lookup[index]\n\n        return specEffic_lookup[index], codeRate_lookup[index], modulationScheme\n\n    def RequiredC_No(self, requiredEs_No, symbolRate):\n        requiredC_No = requiredEs_No + 10 * math.log10(symbolRate) + 60\n        return requiredC_No\n\n    def RequiredC_No2(self, requiredC_N, allocBand):\n        # backtracked from RequiredC_N\n        requiredC_No = requiredC_N+10*math.log10(allocBand)+60\n        return requiredC_No\n\n    def RequiredC_No3(self, Pr_No, margin):\n        # backtracked from Pr_No\n        requiredC_No = Pr_No - margin\n        return requiredC_No\n\n    def RequiredC_No4(self, requiredEb_no, dataRate):\n        requiredC_No = requiredEb_no + 10*math.log10(dataRate * 1e6)\n        return requiredC_No\n\n    def RequiredEs_No(self, requiredC_No, symbolRate):\n        # backtracked from RequiredC_No\n        requiredEs_No = requiredC_No-(10 * math.log10(symbolRate) + 60)\n        return requiredEs_No\n\n    def RequiredEs_No2(self, requiredEb_No, modBits):\n        # backtracked from RequiredEb_No\n        requiredEs_No = requiredEb_No + 10*math.log10(modBits)\n        return requiredEs_No\n\n    def RequiredEb_No(self, requiredEs_No, modBits):\n        requiredEb_No = requiredEs_No - 10*math.log10(modBits)\n        return requiredEb_No\n\n    def RequiredEb_No2(self, requiredC_No, dataRate):\n        requiredEb_No = requiredC_No - 10*math.log10(dataRate * 1e6)\n        return requiredEb_No\n\n    def RequiredC_N(self, requiredC_No, allocBand):\n        requiredC_N = requiredC_No - 10*math.log10(allocBand)-60\n        return requiredC_N\n\n    def RequiredC_N2(self, margin, ActualC_NPlusI):\n        # backtracked from Margin\n        requiredC_N = ActualC_NPlusI - margin\n        return requiredC_N\n\n    def GainsPlusLosses(self, txGain, txFeederLoss, txPointingLoss, propLoss, rxGain, rxPointingLoss, rxFeederLoss, polarizationMismatch):\n        gainLoss = txGain - txFeederLoss - txPointingLoss - propLoss + \\\n            rxGain - rxPointingLoss - rxFeederLoss - polarizationMismatch\n        return gainLoss\n\n    def GainsPlusLosses2(self, carrier, txPAoutDBW):\n        # backtracked from Carrier\n        gainLoss = carrier - txPAoutDBW\n        return gainLoss\n\n    def GainsPlusLosses3(self, linkI_TxNPR, iTxNPR):\n        # backtracked from LinkI_TxNPR\n        gainLoss = linkI_TxNPR - iTxNPR\n        return gainLoss\n\n    def GainsPlusLosses4(self, linkI_TxXPI, iTxXPI):\n        # backtracked from LinkI_TxXPI\n        gainLoss = linkI_TxXPI - iTxXPI\n        return gainLoss\n\n    def Carrier(self, txPAoutDBW, gainLoss):\n        carrier = txPAoutDBW + gainLoss\n        return carrier\n\n    def Carrier2(self, linkI_RxXPI, iRxXPI):\n        # backtracked from LinkI_RxXPI\n        carrier = linkI_RxXPI + iRxXPI\n        return carrier\n\n    def Carrier3(self, actualC_N, noise):\n        # backtracked from ActualC_N\n        carrier = actualC_N + noise\n        return carrier\n\n    def Carrier4(self, C_NPlusI, noise, linkI_TxNPR, linkI_TxXPI, linkI_RxXPI):\n        # backtracked from calcC_NPlusI\n        carrier = 10 * math.log10(math.pow(10, C_NPlusI/10) * ((math.pow(10, noise/10)) + (math.pow(\n            10, linkI_TxNPR/10)) + (math.pow(10, linkI_TxXPI/10)) + (math.pow(10, linkI_RxXPI/10))))\n        return carrier\n\n    def Noise(self, rxSystemNoiseTemp, symbolRate):\n        noise = -228.6+10*math.log10(rxSystemNoiseTemp) + \\\n            10*math.log10(symbolRate*1000000)\n        return noise\n\n    def Noise2(self, actualC_N, carrier):\n        # backtracked from CalcC_N\n        noise = carrier - actualC_N\n        return noise\n\n    def LinkI_TxNPR(self, iTxNPR, gainLoss):\n        linkI_TxNPR = iTxNPR + gainLoss\n        return linkI_TxNPR\n\n    def LinkI_TxXPI(self, iTxXPI, gainLoss):\n        linkI_TxXPI = iTxXPI + gainLoss\n        return linkI_TxXPI\n\n    def LinkI_RxXPI(self, iRxXPI, carrier):\n        linkI_RxXPI = carrier - iRxXPI\n        return linkI_RxXPI\n\n    def ModemLoss(self, ActualC_NPlusI, C_NPlusI):\n        # backtracked from calcActualC_NPlusI\n        modemLoss = C_NPlusI - ActualC_NPlusI\n        return modemLoss\n\n    def ActualC_N(self, carrier, noise):\n        actualC_N = carrier - noise\n        return actualC_N\n\n    def ActualC_N2(self, actualC_No, allocBand):\n        actualC_N = actualC_No - 10*math.log10(allocBand)-60\n        return actualC_N\n\n    def calcC_NPlusI(self, carrier, noise, linkI_TxNPR, linkI_TxXPI, linkI_RxXPI):\n        # make it so that if the interference are unknown, they aren't counted towards C_NPlusI\n\n        if linkI_TxNPR == None:\n            TxNPR = 0\n        else:\n            TxNPR = (math.pow(10, linkI_TxNPR/10))\n\n        if linkI_TxXPI == None:\n            TxXPI = 0\n        else:\n            TxXPI = (math.pow(10, linkI_TxXPI/10))\n\n        if linkI_RxXPI == None:\n            RxXPI = 0\n        else:\n            RxXPI = (math.pow(10, linkI_RxXPI/10))\n\n        interference = TxNPR + TxXPI + RxXPI\n        C_NPlusI = 10*math.log10((math.pow(10, carrier/10)) /\n                                 ((math.pow(10, noise/10)) + interference))\n        return C_NPlusI\n\n    def calcC_NPlusI2(self, ActualC_NPlusI, modemLoss):\n        # backtracked from calcActualC_NPlusI\n        C_NPlusI = ActualC_NPlusI + modemLoss\n        return C_NPlusI\n\n    def calcActualC_NPlusI(self, C_NPlusI, modemLoss):\n        ActualC_NPlusI = C_NPlusI - modemLoss\n        return ActualC_NPlusI\n\n    def calcActualC_NPlusI2(self, margin, requiredC_N):\n        ActualC_NPlusI = margin + requiredC_N\n        return ActualC_NPlusI\n\n    def Margin(self, ActualC_NPlusI, requiredC_N):\n        margin = ActualC_NPlusI - requiredC_N\n        return margin\n\n    def Margin2(self, Pr_No, requiredC_No):\n        # backtracked from Pr_No\n        margin = Pr_No - requiredC_No\n        return margin\n\n    def calcPr_No(self, margin, requiredC_No):\n        Pr_No = margin + requiredC_No\n        return Pr_No\n\n    def ActualC_No(self, actualC_N, allocBand):\n        actualC_No = actualC_N+10*math.log10(allocBand)+60\n        return actualC_No\n\n\n# ----- Logic Group Functions -----#\n\n    def modBits_interaction(self, modBits, modulationScheme):\n        # HANDLING: interaction between modBits and modulationScheme\n        # this interaction will look a bit different since it deals with\n        # a drop down menu\n        try:\n            if modulationScheme != \"    \":\n                modBits = self.ModBits2(modulationScheme)\n\n        except:\n            (modBits) = (\"ERR:UB\")\n\n        return (modBits)\n\n    def waveform_interaction(self, waveform, requiredEs_No, spectralEfficiency, codeRate, modulationScheme):\n        # HANDLING: interaction between waveform, es/no, and spectral efficiency\n        # this interaction will look a bit different because it deals with a\n        # drop down menu that spits out different outputs based on the dropdown\n        # and Es_no\n     #  try:\n\n        if waveform == \"DVB-S2X\" and type(requiredEs_No) is float:\n            spectralEfficiency, codeRate, modulationScheme = self.WaveformOutputs(\n                requiredEs_No, modulationScheme)\n\n  #  except:\n       # (spectralEfficiency) = (\"ERR:UB\")\n\n        return (spectralEfficiency, codeRate, modulationScheme)\n\n    def symbolRate_interaction(self, symbolRate, allocBand, rollOff):\n        # HANDLING: interaction between symbolRate, allocBand, rollOff\n        try:\n            t_symbolRate = 1 if type(symbolRate) is float else 0\n            t_allocBand = 1 if type(allocBand) is float else 0\n            t_rollOff = 1 if type(rollOff) is float else 0\n\n            pattern = (t_symbolRate, t_allocBand, t_rollOff)\n\n            functions = {\n                # If no roll off factor assume .1\n                (0, 0, 0): lambda x, y, z: (None, None, 0.0),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (0, 1, 0): lambda x, y, z: (self.SymbolRate(y, 0.0), y, 0.0),\n                (1, 0, 0): lambda x, y, z: (x, self.AllocBand(x, 0.0), 0.0),\n                (0, 1, 1): lambda x, y, z: (self.SymbolRate(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.RollOff(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, self.AllocBand(x, z), z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n            }\n\n            (symbolRate, allocBand, rollOff) = functions[pattern](\n                symbolRate, allocBand, rollOff)\n        except:\n            (symbolRate, allocBand, rollOff) = (\"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (symbolRate, allocBand, rollOff)\n\n    def dataRate_interaction(self, dataRate, symbolRate, modBits, codeRate, overhead):\n        # HANDLING: interaction between dataRate, symbolRate, modBits, codeRate, overhead\n        try:\n            t_dataRate = 1 if type(dataRate) is float else 0\n            t_symbolRate = 1 if type(symbolRate) is float else 0\n            t_modBits = 1 if type(modBits) is float else 0\n            t_codeRate = 1 if type(codeRate) is float else 0\n            t_overhead = 1 if type(overhead) is float else 0\n\n            pattern = (t_dataRate, t_symbolRate,\n                       t_modBits, t_codeRate, t_overhead)\n\n            functions = {\n                (0, 0, 0, 0, 0): lambda x, y, z, w, v: (None, None, None, None, None),\n                (0, 0, 0, 0, 1): lambda x, y, z, w, v: (None, None, None, None, v),\n                (0, 0, 0, 1, 0): lambda x, y, z, w, v: (None, None, None, w, None),\n                (0, 0, 1, 0, 0): lambda x, y, z, w, v: (None, None, z, None, None),\n                (0, 1, 0, 0, 0): lambda x, y, z, w, v: (None, y, None, None, None),\n                (1, 0, 0, 0, 0): lambda x, y, z, w, v: (x, None, None, None, None),\n\n                (0, 0, 0, 1, 1): lambda x, y, z, w, v: (None, None, None, w, v),\n                (0, 0, 1, 1, 0): lambda x, y, z, w, v: (None, None, z, w, None),\n                (0, 1, 1, 0, 0): lambda x, y, z, w, v: (None, y, z, None, None),\n                (1, 1, 0, 0, 0): lambda x, y, z, w, v: (x, y, None, None, None),\n                (1, 0, 1, 0, 0): lambda x, y, z, w, v: (x, None, z, None, None),\n                (1, 0, 0, 1, 0): lambda x, y, z, w, v: (x, None, None, w, None),\n                (1, 0, 0, 0, 1): lambda x, y, z, w, v: (x, None, None, None, v),\n                (0, 1, 0, 1, 0): lambda x, y, z, w, v: (None, y, None, w, None),\n                (0, 1, 0, 0, 1): lambda x, y, z, w, v: (None, y, None, None, v),\n                (0, 0, 1, 0, 1): lambda x, y, z, w, v: (None, None, z, None, v),\n\n                # assume coding rate is 1\n                (1, 1, 1, 0, 0): lambda x, y, z, w, v: (x, y, z, 1, self.Overhead(x, y, z, 1)),\n                (1, 1, 0, 0, 1): lambda x, y, z, w, v: (x, y, self.ModBits(x, y, 1, v), 1, v),\n                (1, 0, 0, 1, 1): lambda x, y, z, w, v: (x, None, None, w, v),\n                (0, 0, 1, 1, 1): lambda x, y, z, w, v: (None, None, z, w, v),\n                (0, 1, 0, 1, 1): lambda x, y, z, w, v: (None, y, None, w, v),\n                (0, 1, 1, 0, 1): lambda x, y, z, w, v: (self.DataRate(y, z, 1, v), y, z, 1, v),\n                (0, 1, 1, 1, 0): lambda x, y, z, w, v: (None, y, z, w, None),\n                (1, 0, 1, 0, 1): lambda x, y, z, w, v: (x, self.SymbolRate2(x, z, 1, v), z, 1, v),\n                (1, 0, 1, 1, 0): lambda x, y, z, w, v: (x, None, z, w, None),\n                (1, 1, 0, 1, 0): lambda x, y, z, w, v: (x, y, None, w, None),\n\n                (0, 1, 1, 1, 1): lambda x, y, z, w, v: (self.DataRate(y, z, w, v), y, z, w, v),\n                (1, 0, 1, 1, 1): lambda x, y, z, w, v: (x, self.SymbolRate2(x, z, w, v), z, w, v),\n                (1, 1, 0, 1, 1): lambda x, y, z, w, v: (x, y, self.ModBits(x, y, w, v), w, v),\n                (1, 1, 1, 0, 1): lambda x, y, z, w, v: (x, y, z, self.CodeRate(x, y, z, v), v),\n                (1, 1, 1, 1, 0): lambda x, y, z, w, v: (x, y, z, w, self.Overhead(x, y, z, w)),\n                (1, 1, 1, 1, 1): lambda x, y, z, w, v: (x, y, z, w, v),\n            }\n            (dataRate, symbolRate, modBits, codeRate, overhead) = functions[pattern](\n                dataRate, symbolRate, modBits, codeRate, overhead)\n\n        except:\n            (dataRate, symbolRate, modBits, codeRate, overhead) = (\n                \"ERR:UB\", \"ERR:UB\", \"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (dataRate, symbolRate, modBits, codeRate, overhead)\n\n    def dataTransfer_interaction(self, dataTransfer, dataRate, communicationsEfficiency, passDuration):\n       # HANDLING: interaction between dataTransfer, data rate, communications efficiency, and pass duration\n        try:\n            t_dataTransfer = 1 if type(dataTransfer) is float else 0\n            t_dataRate = 1 if type(dataRate) is float else 0\n            t_communicationsEfficiency = 1 if type(\n                communicationsEfficiency) is float else 0\n            t_passDuration = 1 if type(passDuration) is float else 0\n\n            pattern = (t_dataTransfer, t_dataRate,\n                       t_communicationsEfficiency, t_passDuration)\n\n            functions = {\n                (0, 0, 0, 0): lambda x, y, z, w: (None, None, None, None),\n                (0, 0, 0, 1): lambda x, y, z, w: (None, None, None, w),\n                (0, 0, 1, 0): lambda x, y, z, w: (None, None, z, None),\n                (0, 1, 0, 0): lambda x, y, z, w: (None, y, None, None),\n                (1, 0, 0, 0): lambda x, y, z, w: (x, None, None, None),\n                (1, 1, 0, 0): lambda x, y, z, w: (x, y, None, None),\n                (0, 1, 1, 0): lambda x, y, z, w: (None, y, z, None),\n                (0, 0, 1, 1): lambda x, y, z, w: (None, None, z, w),\n                (1, 0, 0, 1): lambda x, y, z, w: (x, None, None, w),\n                (1, 0, 1, 0): lambda x, y, z, w: (x, None, z, None),\n                (0, 1, 0, 1): lambda x, y, z, w: (None, y, None, w),\n                (0, 1, 1, 1): lambda x, y, z, w: (self.DataTransfer(y, z, w), y, z, w),\n                (1, 0, 1, 1): lambda x, y, z, w: (x, self.DataRate2(x, z, w), z, w),\n                (1, 1, 0, 1): lambda x, y, z, w: (x, y, self.CommunicationsEfficiency(x, y, w), w),\n                (1, 1, 1, 0): lambda x, y, z, w: (x, y, z, None),\n                (1, 1, 1, 1): lambda x, y, z, w: (x, y, z, w)\n            }\n\n            (dataTransfer, dataRate, communicationsEfficiency, passDuration) = functions[pattern](\n                dataTransfer, dataRate, communicationsEfficiency, passDuration)\n\n        except:\n            (dataTransfer, dataRate, communicationsEfficiency, passDuration) = (\n                \"ERR:UB\", \"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (dataTransfer, dataRate, communicationsEfficiency, passDuration)\n\n    def spectralEfficiency_interaction(self, spectralEfficiency, dataRate, allocBand):\n        # HANDLING: interaction between spectralEfficiency, dataRate, allocBand\n        try:\n            t_spectralEfficiency = 1 if type(\n                spectralEfficiency) is float else 0\n            t_dataRate = 1 if type(dataRate) is float else 0\n            t_allocBand = 1 if type(allocBand) is float else 0\n\n            pattern = (t_spectralEfficiency, t_dataRate, t_allocBand)\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 1): lambda x, y, z: (self.SpectralEfficiency(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.AllocBand2(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, self.DataRate3(x, z), z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n            }\n\n            (spectralEfficiency, dataRate, allocBand) = functions[pattern](\n                spectralEfficiency, dataRate, allocBand)\n        except:\n            (spectralEfficiency, dataRate, allocBand) = (\n                \"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (spectralEfficiency, dataRate, allocBand)\n\n    def Eb_No_interaction(self, requiredEb_No, requiredEs_No, modBits):\n        try:\n            t_requiredEb_No = 1 if type(requiredEb_No) is float else 0\n            t_requiredEs_No = 1 if type(requiredEs_No) is float else 0\n            t_modBits = 1 if type(modBits) is float else 0\n\n            pattern = (t_requiredEb_No, t_requiredEs_No, t_modBits)\n\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 1): lambda x, y, z: (self.RequiredEb_No(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.ModBits3(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, self.RequiredEs_No2(x, z), z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n            }\n\n            (requiredEb_No, requiredEs_No, modBits) = functions[pattern](\n                requiredEb_No, requiredEs_No, modBits)\n        except:\n            (requiredEb_No, requiredEs_No, modBits) = (\n                \"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (requiredEb_No, requiredEs_No, modBits)\n\n    def requiredC_No_interaction(self, requiredC_No, requiredEs_No, symbolRate):\n        # HANDLING: interaction between requiredC_No, requiredEs_No, symbolRate\n        try:\n            t_requiredC_No = 1 if type(requiredC_No) is float else 0\n            t_requiredEs_No = 1 if type(requiredEs_No) is float else 0\n            t_symbolRate = 1 if type(symbolRate) is float else 0\n\n            pattern = (t_requiredC_No, t_requiredEs_No, t_symbolRate)\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 1): lambda x, y, z: (self.RequiredC_No(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.SymbolRate3(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, self.RequiredEs_No(x, z), z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n            }\n\n            (requiredC_No, requiredEs_No, symbolRate) = functions[pattern](\n                requiredC_No, requiredEs_No, symbolRate)\n\n        except:\n            (requiredC_No, requiredEs_No, symbolRate) = (\n                \"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return requiredC_No, requiredEs_No, symbolRate\n\n    def requiredC_No_interaction2(self, requiredC_No, requiredEb_No, dataRate):\n        # HANDLING: interaction between requiredC_No, requiredEb_No, dataRate\n        try:\n            t_requiredC_No = 1 if type(requiredC_No) is float else 0\n            t_requiredEb_No = 1 if type(requiredEb_No) is float else 0\n            t_dataRate = 1 if type(dataRate) is float else 0\n\n            pattern = (t_requiredC_No, t_requiredEb_No, t_dataRate)\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 1): lambda x, y, z: (self.RequiredC_No4(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.DataRate4(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, self.RequiredEb_No2(x, z), z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n            }\n\n            (requiredC_No, requiredEb_No, dataRate) = functions[pattern](\n                requiredC_No, requiredEb_No, dataRate)\n\n        except:\n            (requiredC_No, requiredEb_No, dataRate) = (\n                \"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return requiredC_No, requiredEb_No, dataRate\n\n    def requiredC_N_interaction(self, requiredC_N, requiredC_No, allocBand):\n        # HANDLING: interation between requiredC_N, requiredC_No, allocBand\n        try:\n            t_requiredC_N = 1 if type(requiredC_N) is float else 0\n            t_requiredC_No = 1 if type(requiredC_No) is float else 0\n            t_allocBand = 1 if type(allocBand) is float else 0\n\n            pattern = (t_requiredC_N, t_requiredC_No, t_allocBand)\n\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 1): lambda x, y, z: (self.RequiredC_N(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.AllocBand3(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, self.RequiredC_No2(x, z), z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n            }\n\n            (requiredC_N, requiredC_No, allocBand) = functions[pattern](\n                requiredC_N, requiredC_No, allocBand)\n        except:\n            (requiredC_N, requiredC_No, allocBand) = (\n                \"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (requiredC_N, requiredC_No, allocBand)\n\n    def gainLoss_interaction(self, gainLoss, txGain, txFeederLoss, txPointingLoss, propLoss, rxGain, rxPointingLoss, rxFeederLoss, polarizationMismatch):\n        # HANDLING: interaction between gainLoss, txGain, txFeederLoss, txPointingLoss, propLoss, rxGain, rxPointingLoss, rxFeederLoss\n        try:\n\n            pattern = [1 if type(n) is float else 0 for n in [gainLoss, txGain, txFeederLoss,\n                                                              txPointingLoss, propLoss, rxGain, rxPointingLoss, rxFeederLoss, polarizationMismatch]]\n\n            # since there are a lot of different patterns, and there won't be situations where we back calculate\n            # the values for parameters in the other tabs, used if statements instead of listing out all the patterns\n            gainLoss_parameters = [gainLoss, txGain, txFeederLoss, txPointingLoss,\n                                   propLoss, rxGain, rxPointingLoss, rxFeederLoss, polarizationMismatch]\n\n            if pattern == [0, 1, 1, 1, 1, 1, 1, 1, 1]:\n                gainLoss = self.GainsPlusLosses(\n                    txGain, txFeederLoss, txPointingLoss, propLoss, rxGain, rxPointingLoss, rxFeederLoss, polarizationMismatch)\n            else:\n                for i in range(len(pattern)):\n                    if pattern[i] == 0:\n                        gainLoss_parameters[i] = None\n\n        except:\n            (gainLoss, txGain, txFeederLoss, txPointingLoss, propLoss, rxGain, rxPointingLoss, rxFeederLoss, polarizationMismatch) = (\n                \"ERR:UB\", \"ERR:UB\", \"ERR:UB\", \"ERR:UB\", \"ERR:UB\", \"ERR:UB\", \"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (gainLoss, txGain, txFeederLoss, txPointingLoss, propLoss, rxGain, rxPointingLoss, rxFeederLoss, polarizationMismatch)\n\n    def carrier_interaction(self, carrier, txPAoutDBW, gainLoss):\n        # HANDLING: interaction between carrier, txPAoutDBW, gainLoss\n        try:\n            t_carrier = 1 if type(carrier) is float else 0\n            t_txPAoutDBW = 1 if type(txPAoutDBW) is float else 0\n            t_gainLoss = 1 if type(gainLoss) is float else 0\n\n            pattern = (t_carrier, t_txPAoutDBW, t_gainLoss)\n\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 1, 1): lambda x, y, z: (self.Carrier(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.GainsPlusLosses2(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, None, z),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n\n            }\n\n            (carrier, txPAoutDBW, gainLoss) = functions[pattern](\n                carrier, txPAoutDBW, gainLoss)\n        except:\n            (carrier, txPAoutDBW, gainLoss) - (\"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (carrier, txPAoutDBW, gainLoss)\n\n    def noise_interaction(self, noise, rxSystemNoiseTemp, symbolRate):\n        # HANDLING: interaction between noise, rxSystemNoiseTemp, symbolRate\n        try:\n            t_noise = 1 if type(noise) is float else 0\n            t_rxSystemNoiseTemp = 1 if type(rxSystemNoiseTemp) is float else 0\n            t_symbolRate = 1 if type(symbolRate) is float else 0\n\n            pattern = (t_noise, t_rxSystemNoiseTemp, t_symbolRate)\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 1, 1): lambda x, y, z: (self.Noise(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.SymbolRate4(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, None, z),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n\n            }\n\n            (noise, rxSystemNoiseTemp, symbolRate) = functions[pattern](\n                noise, rxSystemNoiseTemp, symbolRate)\n\n        except:\n            (noise, rxSystemNoiseTemp, symbolRate) = (\n                \"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (noise, rxSystemNoiseTemp, symbolRate)\n\n    def link_I_TxNPR_interaction(self, linkI_TxNPR, iTxNPR, gainLoss):\n        # HANDLING: interation between linkI_TxNPR, iTxNPR, gainLoss\n        try:\n            t_linkI_TxNPR = 1 if type(linkI_TxNPR) is float else 0\n            t_iTxNPR = 1 if type(iTxNPR) is float else 0\n            t_gainLoss = 1 if type(gainLoss) is float else 0\n\n            pattern = (t_linkI_TxNPR, t_iTxNPR, t_gainLoss)\n\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 1, 1): lambda x, y, z: (self.LinkI_TxNPR(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.GainsPlusLosses3(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, None, z),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n\n            }\n            (linkI_TxNPR, iTxNPR, gainLoss) = functions[pattern](\n                linkI_TxNPR, iTxNPR, gainLoss)\n\n        except:\n            (linkI_TxNPR, iTxNPR, gainLoss) = (\"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (linkI_TxNPR, iTxNPR, gainLoss)\n\n    def LinkI_TxXPI_interaction(self, linkI_TxXPI, iTxXPI, gainLoss):\n        # HANDLING: interation between linkI_TxXPI, iTxXPI, gainLoss\n        try:\n            t_linkI_TxXPI = 1 if type(linkI_TxXPI) is float else 0\n            t_iTxXPI = 1 if type(iTxXPI) is float else 0\n            t_gainLoss = 1 if type(gainLoss) is float else 0\n\n            pattern = (t_linkI_TxXPI, t_iTxXPI, t_gainLoss)\n\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 1, 1): lambda x, y, z: (self.LinkI_TxXPI(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.GainsPlusLosses3(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, None, z),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n\n            }\n            (linkI_TxXPI, iTxXPI, gainLoss) = functions[pattern](\n                linkI_TxXPI, iTxXPI, gainLoss)\n\n        except:\n            (linkI_TxXPI, iTxXPI, gainLoss) = (\"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (linkI_TxXPI, iTxXPI, gainLoss)\n\n    def LinkI_RxXPI_interaction(self, linkI_RxXPI, iRxXPI, carrier):\n        # HANDLING: interaction between linkI_RxXPI, iRxXPI, carrier\n        try:\n            t_linkI_RxXPI = 1 if type(linkI_RxXPI) is float else 0\n            t_iRxXPI = 1 if type(iRxXPI) is float else 0\n            t_carrier = 1 if type(carrier) is float else 0\n\n            pattern = (t_linkI_RxXPI, t_iRxXPI, t_carrier)\n\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 1, 1): lambda x, y, z: (self.LinkI_RxXPI(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.Carrier2(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, None, z),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n\n            }\n            (linkI_RxXPI, iRxXPI, carrier) = functions[pattern](\n                linkI_RxXPI, iRxXPI, carrier)\n\n        except:\n            (linkI_RxXPI, iRxXPI, carrier) = (\"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (linkI_RxXPI, iRxXPI, carrier)\n\n    def C_N_interaction(self, actualC_N, carrier, noise):\n        # HANDLING: interaction between actualC_N, carrier, noise\n        try:\n            t_actualC_N = 1 if type(actualC_N) is float else 0\n            t_carrier = 1 if type(carrier) is float else 0\n            t_noise = 1 if type(noise) is float else 0\n\n            pattern = (t_actualC_N, t_carrier, t_noise)\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 1, 1): lambda x, y, z: (self.ActualC_N(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.Noise2(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, self.Carrier3(x, z), z),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n\n            }\n\n            (actualC_N, carrier, noise) = functions[pattern](\n                actualC_N, carrier, noise)\n\n        except:\n            (actualC_N, carrier, noise) = (\"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (actualC_N, carrier, noise)\n\n    def C_NPlusI_interaction(self, C_NPlusI, carrier, noise, linkI_TxNPR, linkI_TxXPI, linkI_RxXPI):\n        # HANDLING: interaction between C_NPlusI, carrier, noise, linkI_TxNPR, linkI_TxXPI, linkI_RxXPI\n       # try:\n        t_C_NPlusI = 1 if type(C_NPlusI) is float else 0\n        t_carrier = 1 if type(carrier) is float else 0\n        t_noise = 1 if type(noise) is float else 0\n        t_linkI_TxNPR = 1 if type(linkI_TxNPR) is float else 0\n        t_linkI_TxXPI = 1 if type(linkI_TxXPI) is float else 0\n        t_linkI_RxXPI = 1 if type(linkI_RxXPI) is float else 0\n\n        pattern = [t_C_NPlusI, t_carrier, t_noise,\n                   t_linkI_TxNPR, t_linkI_TxXPI, t_linkI_RxXPI]\n        C_NPlusI_parameters = [C_NPlusI, carrier, noise,\n                               linkI_TxNPR, linkI_TxXPI, linkI_RxXPI]\n\n        if pattern == [0, 1, 1, 1, 1, 1]:\n            C_NPlusI = self.calcC_NPlusI(\n                carrier, noise, linkI_TxNPR, linkI_TxXPI, linkI_RxXPI)\n        # assume Interference is 0 if it's not there\n        elif pattern[:3] == [0, 1, 1]:\n            for i in range(len(pattern)):\n                if pattern[i] == 0:\n                    C_NPlusI_parameters[i] = None\n            C_NPlusI, carrier, noise, linkI_TxNPR, linkI_TxXPI, linkI_RxXPI = C_NPlusI_parameters\n            C_NPlusI = self.calcC_NPlusI(\n                carrier, noise, linkI_TxNPR, linkI_TxXPI, linkI_RxXPI)\n        elif pattern == [1, 0, 1, 1, 1, 1]:\n            carrier = self.Carrier4(\n                C_NPlusI, noise, linkI_TxNPR, linkI_TxXPI, linkI_RxXPI)\n\n       # except:\n        #    (C_NPlusI, carrier, noise, linkI_TxNPR, linkI_TxXPI, linkI_RxXPI) = (\"ERR:UB\", \"ERR:UB\", \"ERR:UB\", \"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (C_NPlusI, carrier, noise, linkI_TxNPR, linkI_TxXPI, linkI_RxXPI)\n\n    def ActualC_NPlusI_interaction(self, ActualC_NPlusI, C_NPlusI, modemLoss):\n        # HANDLING: interaction between ActualC_NPlusI, C_NPlusI, modemLoss\n        try:\n            t_ActualC_NPlusI = 1 if type(ActualC_NPlusI) is float else 0\n            t_C_NPlusI = 1 if type(C_NPlusI) is float else 0\n            t_modemLoss = 1 if type(modemLoss) is float else 0\n\n            pattern = (t_ActualC_NPlusI, t_C_NPlusI, t_modemLoss)\n\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 1, 1): lambda x, y, z: (self.calcActualC_NPlusI(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.ModemLoss(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, self.calcC_NPlusI2(x, z), z),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                # assume modemLoss is 0 if not inputed\n                (0, 1, 0): lambda x, y, z: (self.calcActualC_NPlusI(y, 0), y, 0),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n\n            }\n\n            (ActualC_NPlusI, C_NPlusI, modemLoss) = functions[pattern](\n                ActualC_NPlusI, C_NPlusI, modemLoss)\n        except:\n            (ActualC_NPlusI, C_NPlusI, modemLoss) = (\n                \"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (ActualC_NPlusI, C_NPlusI, modemLoss)\n\n    def margin_interaction(self, margin, ActualC_NPlusI, requiredC_N):\n        # HANDLING: interaction between margin, ActucalC_NPlusI, requiredC_N\n        try:\n            t_margin = 1 if type(margin) is float else 0\n            t_ActualC_NPlusI = 1 if type(ActualC_NPlusI) is float else 0\n            t_requiredC_N = 1 if type(requiredC_N) is float else 0\n\n            pattern = (t_margin, t_ActualC_NPlusI, t_requiredC_N)\n\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 1, 1): lambda x, y, z: (self.Margin(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.RequiredC_N2(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, self.calcActualC_NPlusI2(x, z), z),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n\n            }\n\n            (margin, ActualC_NPlusI, requiredC_N) = functions[pattern](\n                margin, ActualC_NPlusI, requiredC_N)\n        except:\n            (margin, ActualC_NPlusI, requiredC_N) = (\n                \"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (margin, ActualC_NPlusI, requiredC_N)\n\n    def Pr_No_interaction(self, Pr_No, margin, requiredC_No):\n        # HANDLING: interaction between margin, ActucalC_NPlusI, requiredC_N\n        try:\n            t_Pr_No = 1 if type(Pr_No) is float else 0\n            t_margin = 1 if type(margin) is float else 0\n            t_requiredC_No = 1 if type(requiredC_No) is float else 0\n\n            pattern = (t_Pr_No, t_margin, t_requiredC_No)\n\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 1, 1): lambda x, y, z: (self.calcPr_No(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.RequiredC_No3(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, self.Margin2(x, z), z),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n\n            }\n\n            (Pr_No, margin, requiredC_No) = functions[pattern](\n                Pr_No, margin, requiredC_No)\n        except:\n            (Pr_No, margin, requiredC_No) = (\"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (Pr_No, margin, requiredC_No)\n\n    def actualC_No_interaction(self, actualC_No, actualC_N, allocBand):\n        # HANDLING: interaction between actualC_No, actualC_N, allocBand\n        try:\n            t_actualC_No = 1 if type(actualC_No) is float else 0\n            t_actualC_N = 1 if type(actualC_N) is float else 0\n            t_allocBand = 1 if type(allocBand) is float else 0\n\n            pattern = (t_actualC_No, t_actualC_N, t_allocBand)\n\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 1, 1): lambda x, y, z: (self.ActualC_No(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.AllocBand4(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, self.ActualC_N2(x, z), z),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n\n            }\n\n            (actualC_No, actualC_N, allocBand) = functions[pattern](\n                actualC_No, actualC_N, allocBand)\n        except:\n            (actualC_No, actualC_N, allocBand) = (\"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (actualC_No, actualC_N, allocBand)\n\n    def powerAtReceiver_interaction(self, txEIRP, rxGain, propagationLoss, rxPointingLoss):\n        if type(txEIRP) == float:\n            terms = [0 if type(i) != float else i for i in [\n                txEIRP, rxGain, propagationLoss, rxPointingLoss]]\n            return sum(terms[0:2]) - sum(terms[2:])\n        else:\n            return None\n\n\n# ----- Run Link Equations -----#\n\n    def runLink(self, parameters: dict):\n        txGain = parameters[\"Tx\"][\"Tx Antenna Gain\"].value\n        txFeederLoss = parameters[\"Tx\"][\"Feeder (Insertion) Loss\"].value\n        txPointingLoss = parameters[\"Tx\"][\"Tx Pointing Loss\"].value\n        propLoss = parameters[\"Propagation\"][\"Total Propagation Loss\"].value\n        rxGain = parameters[\"Rx\"][\"Rx Antenna Gain\"].value\n        rxPointingLoss = parameters[\"Rx\"][\"Rx Pointing Loss\"].value\n        rxFeederLoss = parameters[\"Rx\"][\"Rx Feed and Input Filter Loss\"].value\n        txPAoutDBW = parameters[\"Tx\"][\"Power Amp RF Output (dBW)\"].value\n        rxSystemNoiseTemp = parameters[\"Rx\"][\"Rx System Noise Temperature\"].value\n        rxPointingError = parameters[\"Rx\"][\"Rx Pointing Error\"].value\n        passDuration = parameters[\"Propagation\"][\"Pass Duration\"].value\n        # iTxNPR = parameters[\"Tx\"][\"I - Tx NPR\"].value\n        # iTxXPI = parameters[\"Tx\"][\"I - Tx XPI\"].value\n        # iRxXPI = parameters[\"Rx\"][\"I - Rx XPI\"].value\n        txEIRP = parameters[\"Tx\"][\"Tx EIRP\"].value\n        propagationLoss = parameters[\"Propagation\"][\"Total Propagation Loss\"].value\n\n        allocBand = parameters[\"System\"][\"Allocated Bandwidth Per Carrier\"].value\n        rollOff = parameters[\"Link Performance\"][\"Roll-off Factor\"].value\n        modBits = parameters[\"Link Performance\"][\"Modulation bits/symbol\"].value\n        codeRate = parameters[\"Link Performance\"][\"Code Rate\"].value\n        overhead = parameters[\"Link Performance\"][\"Overhead\"].value\n        requiredEs_No = parameters[\"Link Performance\"][\"Required Es/No\"].value\n        requiredEb_No = parameters[\"Link Performance\"][\"Required Eb/No\"].value\n        communicationsEfficiency = 1.0\n        dataTransfer = parameters[\"Link Performance\"][\"Data Transfer Per Pass\"].value\n        modemLoss = parameters[\"Link Performance\"][\"Modem Implementation Loss\"].value\n        symbolRate = parameters[\"Link Performance\"][\"Symbol Rate\"].value\n        dataRate = parameters[\"Link Performance\"][\"Data Rate\"].value\n        spectralEfficiency = parameters[\"Link Performance\"][\"Spectral Efficiency\"].value\n        requiredC_No = parameters[\"Link Performance\"][\"Required C/No\"].value\n        requiredC_N = parameters[\"Link Performance\"][\"Required C/N\"].value\n        gainLoss = parameters[\"Link Performance\"][\"G_Tx + L_Tx + L_prop + G_Rx + L_Rx\"].value\n        carrier = parameters[\"Link Performance\"][\"C - Carrier\"].value\n        noise = parameters[\"Link Performance\"][\"N - Noise\"].value\n        linkI_TxNPR = None\n        linkI_TxXPI = None\n        linkI_RxXPI = None\n        actualC_N = parameters[\"Link Performance\"][\"Actual C/N\"].value\n        C_NPlusI = parameters[\"Link Performance\"][\"C/N+I\"].value\n        ActualC_NPlusI = parameters[\"Link Performance\"][\"Actual C/N+I\"].value\n        margin = parameters[\"Link Performance\"][\"Margin\"].value\n        Pr_No = parameters[\"Link Performance\"][\"Minimum Pr/No\"].value\n        actualC_No = parameters[\"Link Performance\"][\"Actual C/No\"].value\n        modulationScheme = parameters[\"Link Performance\"][\"Modulation Scheme\"].value\n        waveform = parameters[\"Link Performance\"][\"Waveform\"].value\n        polarizationMismatch = parameters[\"Tx\"][\"Polarization Mismatch\"].value\n\n        modBits = self.modBits_interaction(modBits, modulationScheme)\n        spectralEfficiency, codeRate, modulationScheme = self.waveform_interaction(\n            waveform, requiredEs_No, spectralEfficiency, codeRate, modulationScheme)\n\n        symbolRate, allocBand, rollOff = self.symbolRate_interaction(\n            symbolRate, allocBand, rollOff)\n        dataRate, symbolRate, modBits, codeRate, overhead = self.dataRate_interaction(\n            dataRate, symbolRate, modBits, codeRate, overhead)\n        dataTransfer, dataRate, communicationsEfficiency, passDuration = self.dataTransfer_interaction(\n            dataTransfer, dataRate, communicationsEfficiency, passDuration)\n        requiredC_No, requiredEs_No, symbolRate = self.requiredC_No_interaction(\n            requiredC_No, requiredEs_No, symbolRate)\n        # requiredC_No, requiredEb_No, dataRate = self.requiredC_No_interaction2(\n        #     requiredC_No, requiredEb_No, dataRate)\n        requiredC_N, requiredC_No, allocBand = self.requiredC_N_interaction(\n            requiredC_N, requiredC_No, allocBand)\n        spectralEfficiency, dataRate, allocBand = self.spectralEfficiency_interaction(\n            spectralEfficiency, dataRate, allocBand)\n        requiredEb_No, requiredEs_No, modBits = self.Eb_No_interaction(\n            requiredEb_No, requiredEs_No, modBits)\n        gainLoss, txGain, txFeederLoss, txPointingLoss, propLoss, rxGain, rxPointingLoss, rxFeederLoss, polarizationMismatch = self.gainLoss_interaction(\n            gainLoss, txGain, txFeederLoss, txPointingLoss, propLoss, rxGain, rxPointingLoss, rxFeederLoss, polarizationMismatch)\n        carrier, txPAoutDBW, gainLoss = self.carrier_interaction(\n            carrier, txPAoutDBW, gainLoss)\n        noise, rxSystemNoiseTemp, symbolRate = self.noise_interaction(\n            noise, rxSystemNoiseTemp, symbolRate)\n        # linkI_TxNPR, iTxNPR, gainLoss = self.link_I_TxNPR_interaction(\n        #     linkI_TxNPR, iTxNPR, gainLoss)\n        # linkI_TxXPI, iTxXPI, gainLoss = self.LinkI_TxXPI_interaction(\n        #     linkI_TxXPI, iTxXPI, gainLoss)\n        # linkI_RxXPI, iRxXPI, carrier = self.LinkI_RxXPI_interaction(\n        #     linkI_RxXPI, iRxXPI, carrier)\n        actualC_N, carrier, noise = self.C_N_interaction(\n            actualC_N, carrier, noise)\n        actualC_No, actualC_N, allocBand = self.actualC_No_interaction(\n            actualC_No, actualC_N, allocBand)\n        C_NPlusI, carrier, noise, linkI_TxNPR, linkI_TxXPI, linkI_RxXPI = self.C_NPlusI_interaction(\n            C_NPlusI, carrier, noise, linkI_TxNPR, linkI_TxXPI, linkI_RxXPI)\n        ActualC_NPlusI, C_NPlusI, modemLoss = self.ActualC_NPlusI_interaction(\n            ActualC_NPlusI, C_NPlusI, modemLoss)\n        margin, ActualC_NPlusI, requiredC_N = self.margin_interaction(\n            margin, ActualC_NPlusI, requiredC_N)\n        Pr_No, margin, requiredC_No = self.Pr_No_interaction(\n            Pr_No, margin, requiredC_No)\n        powerAtReceiver = self.powerAtReceiver_interaction(\n            txEIRP, rxGain, propagationLoss, rxPointingLoss)\n\n        parameters[\"Link Performance\"][\"Modulation Scheme\"].value = modulationScheme\n        parameters[\"Link Performance\"][\"Waveform\"].value = waveform\n        parameters[\"Link Performance\"][\"Symbol Rate\"].value = symbolRate\n        parameters[\"Link Performance\"][\"Data Rate\"].value = dataRate\n        parameters[\"Link Performance\"][\"Data Transfer Per Pass\"].value = dataTransfer\n        parameters[\"Link Performance\"][\"Spectral Efficiency\"].value = spectralEfficiency\n        parameters[\"Link Performance\"][\"Required C/No\"].value = requiredC_No\n        parameters[\"Link Performance\"][\"Required C/N\"].value = requiredC_N\n        parameters[\"Link Performance\"][\"G_Tx + L_Tx + L_prop + G_Rx + L_Rx\"].value = gainLoss\n        parameters[\"Link Performance\"][\"C - Carrier\"].value = carrier\n        parameters[\"Link Performance\"][\"N - Noise\"].value = noise\n        # parameters[\"Link Performance\"][\"link I - Tx NPR\"].value = linkI_TxNPR\n        # parameters[\"Link Performance\"][\"link I - Tx XPI\"].value = linkI_TxXPI\n        # parameters[\"Link Performance\"][\"link I - Rx XPI\"].value = linkI_RxXPI\n        parameters[\"Link Performance\"][\"Actual C/N\"].value = actualC_N\n        parameters[\"Link Performance\"][\"C/N+I\"].value = C_NPlusI\n        parameters[\"Link Performance\"][\"Actual C/N+I\"].value = ActualC_NPlusI\n        parameters[\"Link Performance\"][\"Margin\"].value = margin\n        parameters[\"Link Performance\"][\"Roll-off Factor\"].value = rollOff\n        parameters[\"Link Performance\"][\"Modulation bits/symbol\"].value = modBits\n        parameters[\"Link Performance\"][\"Code Rate\"].value = codeRate\n        parameters[\"Link Performance\"][\"Overhead\"].value = overhead\n        parameters[\"Link Performance\"][\"Required Es/No\"].value = requiredEs_No\n        parameters[\"Link Performance\"][\"Required Eb/No\"].value = requiredEb_No\n        # parameters[\"Link Performance\"][\"Communications Efficiency\"].value = communicationsEfficiency\n        parameters[\"Link Performance\"][\"Power in Front of Receiver\"].value = powerAtReceiver\n        parameters[\"Link Performance\"][\"Modem Implementation Loss\"].value = modemLoss\n        parameters[\"Link Performance\"][\"Minimum Pr/No\"].value = Pr_No\n        parameters[\"Link Performance\"][\"Actual C/No\"].value = actualC_No\n", "type": "text"}, {"name": "Equation_Files/Propagation_Equations.py", "content": "import Equation_Files.Equation_Constants as Constants\nimport math\nimport numpy as np\nfrom pathlib import Path\n\n\nclass Calculate_Propagation():\n\n    # ----- Calculation Functions -----#\n\n    def Beta(self, altitude, elevationAngle):\n        beta = math.asin((Constants.r_E/(Constants.r_E+altitude))\n                         * math.sin(math.pi*(90+elevationAngle)/180))*180/math.pi\n        return beta\n\n    def Beta2(self, gamma, elevationAngle):\n        # backtracked from gamma\n        beta = 90-elevationAngle-gamma\n        return beta\n\n    def Gamma(self, beta, elevationAngle):\n        gamma = 90-beta-elevationAngle\n        return gamma\n\n    def Gamma2(self, passDuration, altitude, orbitalSpeed):\n        # backtracked from PassDuration\n        gamma = passDuration*orbitalSpeed*60 * \\\n            90/(math.pi*(Constants.r_E+altitude))\n        return gamma\n\n    def ElevationAngle(self, beta, altitude):\n        # backtracked from Beta\n        elevationAngle = -(math.asin(math.sin(beta*math.pi/180) /\n                           (Constants.r_E/(Constants.r_E+altitude)))*180/math.pi-90)\n        return elevationAngle\n\n    def ElevationAngle2(self, gamma, beta):\n        # backtracked from Gamma\n        elevationAngle = 90-beta-gamma\n        return elevationAngle\n\n    def PassDuration(self, altitude, gamma, orbitalSpeed):\n        passDuration = (math.pi*(Constants.r_E+altitude)\n                        * gamma/90)/orbitalSpeed/60\n        return passDuration\n\n    def FreeSpacePathLoss(self, wavelength, pathLength):\n        FSPL = 20*math.log10(4*math.pi*(pathLength*1000)/wavelength)\n        return FSPL\n\n    def FreeSpacePathLoss2(self, rainFade, gasLoss, propLoss):\n        # backtracked from TotalPropagationLoss\n        FSPL = propLoss - gasLoss - rainFade\n        return FSPL\n\n    def PathLength(self, wavelength, FSPL):\n        # backtracked from FSPL\n        pathLength = math.pow(10, FSPL/20)*wavelength/(4*math.pi*1000)\n        return pathLength\n\n    def PathLength2(self, altitude, elevationAngle):\n        pathLength = math.sqrt(Constants.r_E**2 + ((Constants.r_E+altitude))**2 - 2*Constants.r_E*((Constants.r_E+altitude))*math.sin(\n            (elevationAngle*math.pi/180) + math.asin((Constants.r_E/(Constants.r_E+altitude))*math.cos((elevationAngle*math.pi/180)))))\n        return pathLength\n\n    def TotalPropagationLoss(self, FSPL, rainFade, gasLoss):\n        propLoss = FSPL + gasLoss + rainFade\n        return propLoss\n\n    # ----- Logic Group Functions -----#\n    def pathLength_interaction(self, pathLength, altitude, elevationAngle):\n        # HANDLING: interaction between pathLength, altitude, and elevationAngle\n        try:\n            t_pathLength = 1 if type(pathLength) is float else 0\n            t_altitude = 1 if type(altitude) is float else 0\n            t_elevationAngle = 1 if type(elevationAngle) is float else 0\n            pattern = (t_pathLength, t_altitude, t_elevationAngle)\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 1, 1): lambda x, y, z: (self.PathLength2(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, None),\n                (1, 0, 1): lambda x, y, z: (x, None, z),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n\n            }\n\n            (pathLength, altitude, elevationAngle) = functions[pattern](\n                pathLength, altitude, elevationAngle)\n\n        except:\n            (pathLength, altitude, elevationAngle) = (\n                \"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (pathLength, altitude, elevationAngle)\n\n    def beta_interaction(self, beta, altitude, elevationAngle):\n        # HANDLING: interaction between beta, altitude, and elevation angle\n        try:\n            t_beta = 1 if type(beta) is float else 0\n            t_altitude = 1 if type(altitude) is float else 0\n            t_elevationAngle = 1 if type(elevationAngle) is float else 0\n            pattern = (t_beta, t_altitude, t_elevationAngle)\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 1, 1): lambda x, y, z: (self.Beta(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.ElevationAngle(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, None, z),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n\n            }\n\n            (beta, altitude, elevationAngle) = functions[pattern](\n                beta, altitude, elevationAngle)\n\n        except:\n            (beta, altitude, elevationAngle) = (\"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (beta, altitude, elevationAngle)\n\n    def gamma_interaction(self, gamma, beta, elevationAngle):\n       # HANDLING: interaction between gamma, beta, and elevation angle\n        try:\n            t_gamma = 1 if type(gamma) is float else 0\n            t_beta = 1 if type(beta) is float else 0\n            t_elevationAngle = 1 if type(elevationAngle) is float else 0\n            pattern = (t_gamma, t_beta, t_elevationAngle)\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 1, 1): lambda x, y, z: (self.Gamma(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.ElevationAngle2(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, self.Beta2(x, z), z),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n\n            }\n\n            (gamma, beta, elevationAngle) = functions[pattern](\n                gamma, beta, elevationAngle)\n\n        except:\n            (gamma, beta, elevationAngle) = (\"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (gamma, beta, elevationAngle)\n\n    def passDuration_interaction(self, passDuration, altitude, gamma, orbitalSpeed):\n        # HANDLING: interaction between passDuration, altitude, gamma, and orbitalSpeed\n        try:\n            t_passDuration = 1 if type(passDuration) is float else 0\n            t_altitude = 1 if type(altitude) is float else 0\n            t_gamma = 1 if type(gamma) is float else 0\n            t_orbitalSpeed = 1 if type(orbitalSpeed) is float else 0\n            pattern = (t_passDuration, t_altitude, t_gamma, t_orbitalSpeed)\n\n            functions = {\n                (0, 0, 0, 0): lambda x, y, z, w: (None, None, None, None),\n                (0, 0, 0, 1): lambda x, y, z, w: (None, None, None, w),\n                (0, 0, 1, 0): lambda x, y, z, w: (None, None, z, None),\n                (0, 1, 0, 0): lambda x, y, z, w: (None, y, None, None),\n                (1, 0, 0, 0): lambda x, y, z, w: (x, None, None, None),\n                (1, 1, 0, 0): lambda x, y, z, w: (x, y, None, None),\n                (0, 1, 1, 0): lambda x, y, z, w: (None, y, z, None),\n                (0, 0, 1, 1): lambda x, y, z, w: (None, None, z, w),\n                (1, 0, 0, 1): lambda x, y, z, w: (x, None, None, w),\n                (1, 0, 1, 0): lambda x, y, z, w: (x, None, z, None),\n                (0, 1, 0, 1): lambda x, y, z, w: (None, y, None, w),\n                (0, 1, 1, 1): lambda x, y, z, w: (self.PassDuration(y, z, w), y, z, w),\n                (1, 0, 1, 1): lambda x, y, z, w: (x, None, z, w),\n                (1, 1, 0, 1): lambda x, y, z, w: (x, y, self.Gamma2(x, y, w), w),\n                (1, 1, 1, 0): lambda x, y, z, w: (x, y, z, None),\n                (1, 1, 1, 1): lambda x, y, z, w: (x, y, z, w)\n            }\n\n            (passDuration, altitude, gamma, orbitalSpeed) = functions[pattern](\n                passDuration, altitude, gamma, orbitalSpeed)\n\n        except:\n            (passDuration, altitude, gamma, orbitalSpeed) = (\n                \"ERR:UB\", \"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (passDuration, altitude, gamma, orbitalSpeed)\n\n    def FSPL_interaction(self, wavelength, pathLength, FSPL):\n        # HANDLING: interaction between path length, free space path loss, and wavelength\n        try:\n            t_wavelength = 1 if type(wavelength) is float else 0\n            t_pathLength = 1 if type(pathLength) is float else 0\n            t_FSPL = 1 if type(FSPL) is float else 0\n            pattern = (t_wavelength, t_pathLength, t_FSPL)\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 1, 1): lambda x, y, z: (None, y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.FreeSpacePathLoss(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, self.PathLength(x, z), z),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n\n            }\n\n            (wavelength, pathLength, FSPL) = functions[pattern](\n                wavelength, pathLength, FSPL)\n\n        except:\n            (wavelength, pathLength, FSPL) = (\"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (wavelength, pathLength, FSPL)\n\n    def propLoss_interaction(self, FSPL, rainFade, gasLoss, propLoss):\n        # HANDLING: interaction between FSPL, RainFade, gassLoss, and propLoss\n        try:\n            t_FSPL = 1 if type(FSPL) is float else 0\n            t_rainFade = 1 if type(rainFade) is float else 0\n            t_gasLoss = 1 if type(gasLoss) is float else 0\n            t_propLoss = 1 if type(propLoss) is float else 0\n            pattern = (t_FSPL, t_rainFade, t_gasLoss, t_propLoss)\n\n            functions = {\n                # If no rain fade or gas loss assume 0.0 for both\n                (0, 0, 0, 0): lambda x, y, z, w: (None, None, None, None),\n                (0, 0, 0, 1): lambda x, y, z, w: (self.FreeSpacePathLoss2(0.0, 0.0, w), 0.0, 0.0, w),\n                (0, 0, 1, 0): lambda x, y, z, w: (None, None, z, None),\n                (0, 1, 0, 0): lambda x, y, z, w: (None, y, None, None),\n                (1, 0, 0, 0): lambda x, y, z, w: (x, None, None, self.TotalPropagationLoss(x, 0.0, 0.0)),\n\n                (1, 1, 0, 0): lambda x, y, z, w: (x, y, 0.0, self.TotalPropagationLoss(x, y, 0.0)),\n                (0, 1, 1, 0): lambda x, y, z, w: (None, y, z, None),\n                (0, 0, 1, 1): lambda x, y, z, w: (self.FreeSpacePathLoss2(0.0, z, w), 0.0, z, w),\n                (1, 0, 0, 1): lambda x, y, z, w: (x, None, 0.0, w),\n                (1, 0, 1, 0): lambda x, y, z, w: (x, 0.0, z, self.TotalPropagationLoss(x, 0.0, z)),\n                (0, 1, 0, 1): lambda x, y, z, w: (self.FreeSpacePathLoss2(y, 0.0, w), y, 0.0, w),\n\n                (0, 1, 1, 1): lambda x, y, z, w: (self.FreeSpacePathLoss2(y, z, w), y, z, w),\n                (1, 0, 1, 1): lambda x, y, z, w: (x, None, z, w),\n                (1, 1, 0, 1): lambda x, y, z, w: (x, y, None, w),\n                (1, 1, 1, 0): lambda x, y, z, w: (x, y, z, self.TotalPropagationLoss(x, y, z)),\n                (1, 1, 1, 1): lambda x, y, z, w: (x, y, z, w)\n            }\n\n            (FSPL, rainFade, gasLoss, propLoss) = functions[pattern](\n                FSPL, rainFade, gasLoss, propLoss)\n\n        except:\n            (FSPL, rainFade, gasLoss, propLoss) = (\n                \"ERR:UB\", \"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (FSPL, rainFade, gasLoss, propLoss)\n\n    # ----- Run System Equations -----#\n\n    def runPropagation(self, parameters: dict):\n        wavelength = parameters[\"System\"][\"Wavelength\"].value\n        pathLength = parameters[\"Propagation\"][\"Path Length\"].value\n        FSPL = parameters[\"Propagation\"][\"Free Space Path Loss\"].value\n        propLoss = parameters[\"Propagation\"][\"Total Propagation Loss\"].value\n        gasLoss = parameters[\"Propagation\"][\"Atmospheric Gas Losses\"].value\n        rainFade = parameters[\"Propagation\"][\"Rain Fade\"].value\n        altitude = parameters[\"System\"][\"Altitude\"].value\n        elevationAngle = parameters[\"Propagation\"][\"Elevation Angle\"].value\n        beta = parameters[\"Propagation\"][\"Beta\"].value\n        gamma = parameters[\"Propagation\"][\"Gamma\"].value\n        orbitalSpeed = parameters[\"System\"][\"Orbital Speed\"].value\n        passDuration = parameters[\"Propagation\"][\"Pass Duration\"].value\n\n        # latitude = parameters[\"System\"][\"Latitude\"].value\n        # longitude = parameters[\"System\"][\"Longitude\"].value\n        frequency = parameters[\"System\"][\"Frequency\"].value\n        # pressure = parameters[\"System\"][\"Pressure\"].value\n        pressure = None\n\n        pathLength, altitude, elevationAngle = self.pathLength_interaction(\n            pathLength, altitude, elevationAngle)\n        beta, altitude, elevationAngle = self.beta_interaction(\n            beta, altitude, elevationAngle)\n        gamma, beta, elevationAngle = self.gamma_interaction(\n            gamma, beta, elevationAngle)\n        passDuration, altitude, gamma, orbitalSpeed = self.passDuration_interaction(\n            passDuration, altitude, gamma, orbitalSpeed)\n        wavelength, pathLength, FSPL = self.FSPL_interaction(\n            wavelength, pathLength, FSPL)\n        # latitude, longitude, frequency, elevationAngle, rainFade = self.rainFade_interaction(\n        #     latitude, longitude, frequency, elevationAngle, rainFade)\n        # latitude, longitude, frequency, elevationAngle, pressure, gasLoss = self.gasLoss_interaction(\n        #     latitude, longitude, frequency, elevationAngle, pressure, gasLoss)\n        FSPL, rainFade, gasLoss, propLoss = self.propLoss_interaction(\n            FSPL, rainFade, gasLoss, propLoss)\n\n        parameters[\"Propagation\"][\"Beta\"].value = beta\n        parameters[\"Propagation\"][\"Gamma\"].value = gamma\n        parameters[\"Propagation\"][\"Pass Duration\"].value = passDuration\n        parameters[\"Propagation\"][\"Elevation Angle\"].value = elevationAngle\n        parameters[\"Propagation\"][\"Free Space Path Loss\"].value = FSPL\n        parameters[\"Propagation\"][\"Path Length\"].value = pathLength\n        parameters[\"Propagation\"][\"Total Propagation Loss\"].value = propLoss\n        parameters[\"Propagation\"][\"Rain Fade\"].value = rainFade\n        parameters[\"Propagation\"][\"Atmospheric Gas Losses\"].value = gasLoss\n", "type": "text"}, {"name": "Equation_Files/Receiver_Equations.py", "content": "import math\n\n\nclass Calculate_Receiver():\n\n    # ----- Calculation Functions -----#\n\n    # ----- Temp Equations -------#\n    def RxLNANoiseTemp(self, rxLNANoiseFigure):\n        rxLNANoiseTemp = 290 * ((math.pow(10, rxLNANoiseFigure/10))-1)\n        return rxLNANoiseTemp\n\n    def RxLNANoiseTemp2(self, rxSystemNoiseTemp, rxFilterLoss, rxAntennaTemp, rxOpTemp):\n        # backtracked from SystemNoiseTemp\n        rxLNANoiseTemp = rxSystemNoiseTemp - \\\n            (rxAntennaTemp/(math.pow(10, rxFilterLoss/10)) +\n             rxOpTemp*(1-(1/(math.pow(10, rxFilterLoss/10)))))\n        return rxLNANoiseTemp\n\n    def RxLNANoiseFigure(self, rxLNANoiseTemp):\n        rxLNANoiseFigure = 10*(math.log10(rxLNANoiseTemp/290+1))\n        return rxLNANoiseFigure\n\n    def RxLNANoiseFigure2(self, rxNoiseFactor):\n        # backtracked from RxNoiseFactor\n        rxNoiseFigure = 10*math.log10(rxNoiseFactor)\n        return rxNoiseFigure\n\n    def RxNoiseFactor(self, rxNoiseFigure):\n        rxNoiseFactor = math.pow(10, rxNoiseFigure/10)\n        return rxNoiseFactor\n\n    def SystemNoiseTemp(self, rxFilterLoss, rxAntennaTemp, rxOpTemp, rxLNANoiseTemp):\n        rxSystemNoiseTemp = rxAntennaTemp/(math.pow(10, rxFilterLoss/10))+rxOpTemp*(\n            1-(1/(math.pow(10, rxFilterLoss/10))))+rxLNANoiseTemp\n        return rxSystemNoiseTemp\n\n    def SystemNoiseTemp2(self, rxGT, rxGain, rxPointingLoss, rxFilterLoss):\n        # backtracked from RxGT\n        rxSystemNoiseTemp = math.pow(\n            10, (rxGain - rxPointingLoss - rxFilterLoss - rxGT)/10)\n        return rxSystemNoiseTemp\n\n    def RxGT(self, rxGain, rxPointingLoss, rxFilterLoss, rxSystemNoiseTemp):\n        rxGT = rxGain - rxPointingLoss - rxFilterLoss - \\\n            10 * math.log10(rxSystemNoiseTemp)\n        return rxGT\n\n# ----------------------------#\n# ------RX Equations ---------#\n    def RxBeamwidth(self, rxDiameter, wavelength):\n        rxBeamwidth = 70*wavelength / rxDiameter\n        return rxBeamwidth\n\n    def RxBeamwidth2(self, rxPointingLoss, rxPointingError):\n        # backtracked from RxPointingLoss()\n        rxBeamwidth = rxPointingError/math.pow(rxPointingLoss/12, 1/2)\n        return rxBeamwidth\n\n    def RxDiameter(self, rxBeamwidth, wavelength):\n        # backtracked from RxBeamwidth()\n        rxDiameter = 70*wavelength / rxBeamwidth\n        return rxDiameter\n\n    def RxDiameter2(self, rxGain, rxEfficiency, wavelength):\n        # backtracked from RxAntennaGain\n        rxDiameter = math.pow(\n            10, (rxGain - 10*math.log10(rxEfficiency))/20)*wavelength/math.pi\n        return rxDiameter\n\n    def RxPointingError(self, rxPointingLoss, rxBeamwidth):\n        # backtracked from RxPointingLoss()\n        rxPointingError = math.sqrt(rxPointingLoss/12)*rxBeamwidth\n        return rxPointingError\n\n    def RxEfficiency(self, rxGain, rxDiameter, wavelength):\n        # backtracked from RxAntennaGain()\n        rxEfficiency = math.pow(\n            10, (rxGain - 20*math.log10((math.pi*rxDiameter)/wavelength))/10)\n        return rxEfficiency\n\n    def RxAntennaTemp(self, rxSystemNoiseTemp, rxFilterLoss, rxOpTemp, rxLNANoiseTemp):\n        # backtracked from SystemNoiseTemp()\n        rxAntennaTemp = (rxSystemNoiseTemp - rxOpTemp*(1-(1/(math.pow(10, rxFilterLoss/10)))\n                                                       ) - rxLNANoiseTemp)*(math.pow(10, rxFilterLoss/10))\n        return rxAntennaTemp\n\n    def RxFilterLoss(self, rxSystemNoiseTemp, rxAntennaTemp, rxOpTemp, rxLNANoiseTemp):\n        # backtracked from RxAntennaTemp()\n        rxFilterLoss = (10*math.log10((rxOpTemp - rxAntennaTemp) /\n                        (rxLNANoiseTemp + rxOpTemp - rxSystemNoiseTemp)))/math.log10(10)\n        return rxFilterLoss\n\n    def RxFilterLoss2(self, rxGT, rxGain, rxPointingLoss, rxSystemNoiseTemp):\n        rxFilterLoss = rxGain - rxPointingLoss - \\\n            10 * math.log10(rxSystemNoiseTemp) - rxGT\n        return rxFilterLoss\n\n    def RxOpTemp(self, rxSystemNoiseTemp, rxFilterLoss, rxAntennaTemp, rxLNANoiseTemp):\n        # backtracked from SystemNoiseTemp()\n        rxOpTemp = (rxSystemNoiseTemp - rxAntennaTemp/(math.pow(10, rxFilterLoss/10)\n                                                       ) - rxLNANoiseTemp) / (1-(1/(math.pow(10, rxFilterLoss/10))))\n        return rxOpTemp\n\n    def RxPointingLoss(self, rxPointingError, rxBeamwidth):\n        rxPointingLoss = 12*math.pow(rxPointingError/rxBeamwidth, 2)\n        return rxPointingLoss\n\n    def RxPointingLoss2(self, rxGT, rxGain, rxFilterLoss, rxSystemNoiseTemp):\n        rxPointingLoss = rxGain - rxFilterLoss - \\\n            10 * math.log10(rxSystemNoiseTemp) - rxGT\n        return rxPointingLoss\n\n    def RxAntennaGain(self, rxEfficiency, rxDiameter, wavelength):\n        rxGain = 10*math.log10(rxEfficiency) + 20 * \\\n            math.log10((math.pi*rxDiameter)/wavelength)\n        return rxGain\n\n    def RxAntennaGain2(self, rxGT, rxPointingLoss, rxFilterLoss, rxSystemNoiseTemp):\n        # backtracked fromRxGT\n        rxGain = rxGT + rxPointingLoss + rxFilterLoss + \\\n            10 * math.log10(rxSystemNoiseTemp)\n        return rxGain\n\n    # ----- Logic Group Functions -----#\n\n    def rxNoiseFactor_interaction(self, rxNoiseFactor, rxLNANoiseFigure):\n        # HANDLING: interaction between rxNoiseFactor and rxLNANoiseFigure\n        try:\n            t_rxNoiseFactor = 1 if type(rxNoiseFactor) is float else 0\n            t_rxLNANoiseFigure = 1 if type(rxLNANoiseFigure) is float else 0\n            pattern = (t_rxNoiseFactor, t_rxLNANoiseFigure)\n\n            functions = {\n\n                (0, 0): lambda x, y: (None, None),\n                (0, 1): lambda x, y: (self.RxNoiseFactor(y), y),\n                (1, 0): lambda x, y: (x, self.RxLNANoiseFigure2(x)),\n                (1, 1): lambda x, y: (x, y)\n            }\n\n            (rxNoiseFactor, rxLNANoiseFigure) = functions[pattern](\n                rxNoiseFactor, rxLNANoiseFigure)\n        except:\n            (rxNoiseFactor, rxLNANoiseFigure) = (\"ERR:UB\", \"ERR:UB\")\n\n        return (rxNoiseFactor, rxLNANoiseFigure)\n\n    def RxBeamwidth_interaction(self, rxBeamwidth, rxDiameter, wavelength):\n        # HANDLING: interaction between rxBeamwidth, rxDiameter, wavelength\n        try:\n            t_rxBeamwidth = 1 if type(rxBeamwidth) is float else 0\n            t_rxDiameter = 1 if type(rxDiameter) is float else 0\n            t_wavelength = 1 if type(wavelength) is float else 0\n\n            pattern = (t_rxBeamwidth, t_rxDiameter, t_wavelength)\n\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 1): lambda x, y, z: (self.RxBeamwidth(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, None),\n                (1, 0, 1): lambda x, y, z: (x, self.RxDiameter(x, z), z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n            }\n            (rxBeamwidth, rxDiameter, wavelength) = functions[pattern](\n                rxBeamwidth, rxDiameter, wavelength)\n        except:\n            (rxBeamwidth, rxDiameter, wavelength) = (\n                \"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (rxBeamwidth, rxDiameter, wavelength)\n\n    def RxAntennaGain_interaction(self, rxGain, rxEfficiency, rxDiameter, wavelength):\n        # HANDLING: interaction between rxGain, rxEffiency, rxDiameter, wavelength\n        try:\n            # need efficiency, diameter, wavelength\n            t_rxGain = 1 if type(rxGain) is float else 0\n            # need gain, diameter, wavelength\n            t_rxEfficiency = 1 if type(rxEfficiency) is float else 0\n            # need beamwidth, wavelength\n            t_rxDiameter = 1 if type(rxDiameter) is float else 0\n            t_wavelength = 1 if type(\n                wavelength) is float else 0  # need frequency\n\n            pattern = (t_rxGain, t_rxEfficiency, t_rxDiameter, t_wavelength)\n\n            functions = {\n                (0, 0, 0, 0): lambda x, y, z, w: (None, None, None, None),\n                (0, 0, 0, 1): lambda x, y, z, w: (None, None, None, w),\n                (0, 0, 1, 0): lambda x, y, z, w: (None, None, z, None),\n                (0, 1, 0, 0): lambda x, y, z, w: (None, y, None, None),\n                (1, 0, 0, 0): lambda x, y, z, w: (x, None, None, None),\n                (1, 1, 0, 0): lambda x, y, z, w: (x, y, None, None),\n                (0, 1, 1, 0): lambda x, y, z, w: (None, y, z, None),\n                (0, 0, 1, 1): lambda x, y, z, w: (self.RxAntennaGain(0.65, z, w), 0.65, z, w),\n                (1, 0, 0, 1): lambda x, y, z, w: (x, 0.65, self.RxDiameter2(x, 0.65, w), w),\n                (1, 0, 1, 0): lambda x, y, z, w: (x, None, z, None),\n                (0, 1, 0, 1): lambda x, y, z, w: (None, y, None, w),\n                (0, 1, 1, 1): lambda x, y, z, w: (self.RxAntennaGain(y, z, w), y, z, w),\n                (1, 0, 1, 1): lambda x, y, z, w: (x, self.RxEfficiency(x, z, w), z, w),\n                (1, 1, 0, 1): lambda x, y, z, w: (x, y, self.RxDiameter2(x, y, w), w),\n                (1, 1, 1, 0): lambda x, y, z, w: (x, y, z, None),\n                (1, 1, 1, 1): lambda x, y, z, w: (x, y, z, w)\n            }\n\n            (rxGain, rxEfficiency, rxDiameter, wavelength) = functions[pattern](\n                rxGain, rxEfficiency, rxDiameter, wavelength)\n\n        except:\n            (rxGain, rxEfficiency, rxDiameter, wavelength) = (\n                \"ERR:UB\", \"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (rxGain, rxEfficiency, rxDiameter, wavelength)\n\n    def RxPointingLoss_interaction(self, rxPointingLoss, rxPointingError, rxBeamwidth):\n        # HANDLING: interaction between rxPointingLoss, rxPointingError, rxBeamwidth\n        try:\n            t_rxPointingLoss = 1 if type(rxPointingLoss) is float else 0\n            t_rxPointingError = 1 if type(rxPointingError) is float else 0\n            t_rxBeamwidth = 1 if type(rxBeamwidth) is float else 0\n\n            pattern = (t_rxPointingLoss, t_rxPointingError, t_rxBeamwidth)\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 1): lambda x, y, z: (self.RxPointingLoss(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.RxBeamwidth2(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, self.RxPointingError(x, z), z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n            }\n\n            (rxPointingLoss, rxPointingError, rxBeamwidth) = functions[pattern](\n                rxPointingLoss, rxPointingError, rxBeamwidth)\n\n        except:\n            (rxPointingLoss, rxPointingError, rxBeamwidth) = (\n                \"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (rxPointingLoss, rxPointingError, rxBeamwidth)\n\n    # HANDLING: interation between rxLNANoiseTemp and rxLNANoiseFigure\n\n    def RxLNANoiseTemp_interaction(self, rxLNANoiseTemp, rxLNANoiseFigure):\n        try:\n            t_rxLNANoiseTemp = 1 if type(rxLNANoiseTemp) is float else 0\n            t_rxLNANoiseFigure = 1 if type(rxLNANoiseFigure) is float else 0\n\n            pattern = (t_rxLNANoiseTemp, t_rxLNANoiseFigure)\n\n            functions = {\n                (0, 0): lambda x, y: (None, None),\n                (0, 1): lambda x, y: (self.RxLNANoiseTemp(y), y),\n                (1, 0): lambda x, y: (x, self.RxLNANoiseFigure(x)),\n                (1, 1): lambda x, y: (x, y)\n            }\n\n            (rxLNANoiseTemp, rxLNANoiseFigure) = functions[pattern](\n                rxLNANoiseTemp, rxLNANoiseFigure)\n\n        except:\n            (rxLNANoiseTemp, rxLNANoiseFigure) = (\"ERR:UB\", \"ERR:UB\")\n\n        return (rxLNANoiseTemp, rxLNANoiseFigure)\n\n    def SystemNoiseTemp_interaction(self, rxSystemNoiseTemp, rxFilterLoss, rxAntennaTemp, rxOpTemp, rxLNANoiseTemp):\n        # HANDLING: interaction between rxSystemNoiseTemp, rxFilterLoss, rxAntennaTemp, rxOpTemp, rxLNANoiseTemp\n        try:\n            t_rxSystemNoiseTemp = 1 if type(rxSystemNoiseTemp) is float else 0\n            t_rxFilterLoss = 1 if type(rxFilterLoss) is float else 0\n            t_rxAntennaTemp = 1 if type(rxAntennaTemp) is float else 0\n            t_rxOpTemp = 1 if type(rxOpTemp) is float else 0\n            t_rxLNANoiseTemp = 1 if type(rxLNANoiseTemp) is float else 0\n\n            pattern = (t_rxSystemNoiseTemp, t_rxFilterLoss,\n                       t_rxAntennaTemp, t_rxOpTemp, t_rxLNANoiseTemp)\n\n            functions = {\n                (0, 0, 0, 0, 0): lambda x, y, z, w, v: (None, None, None, None, None),\n                (0, 0, 0, 0, 1): lambda x, y, z, w, v: (None, None, None, None, v),\n                (0, 0, 0, 1, 0): lambda x, y, z, w, v: (None, None, None, w, None),\n                (0, 0, 1, 0, 0): lambda x, y, z, w, v: (None, None, z, None, None),\n                (0, 1, 0, 0, 0): lambda x, y, z, w, v: (None, y, None, None, None),\n                (1, 0, 0, 0, 0): lambda x, y, z, w, v: (x, None, None, None, None),\n\n                # if system noise temp is given (and no feeder temp), assume feeder temp = 290k\n                # assume 0.0 db for feeder loss\n                (0, 0, 0, 1, 1): lambda x, y, z, w, v: (None, None, None, w, v),\n                (0, 0, 1, 1, 0): lambda x, y, z, w, v: (None, None, z, w, None),\n                (0, 1, 1, 0, 0): lambda x, y, z, w, v: (None, y, z, None, None),\n                (1, 1, 0, 0, 0): lambda x, y, z, w, v: (x, y, None, None, None),\n                (1, 0, 1, 0, 0): lambda x, y, z, w, v: (x, 0.0, z, 290, self.RxLNANoiseTemp2(x, 0.0, z, 290)),\n                (1, 0, 0, 1, 0): lambda x, y, z, w, v: (x, None, None, w, None),\n                (1, 0, 0, 0, 1): lambda x, y, z, w, v: (x, 0.0, self.RxAntennaTemp(x, 0.0, 290, v), 290, v),\n                (0, 1, 0, 1, 0): lambda x, y, z, w, v: (None, y, None, w, None),\n                (0, 1, 0, 0, 1): lambda x, y, z, w, v: (None, y, None, None, v),\n                (0, 0, 1, 0, 1): lambda x, y, z, w, v: (None, None, z, None, v),\n\n\n                # if system noise temp is given (and no feeder temp), assume feeder temp = 290k\n                # assume 0.0 db for feeder loss\n                (1, 1, 1, 0, 0): lambda x, y, z, w, v: (x, y, z, 290, self.RxLNANoiseTemp2(x, y, z, 290)),\n                (1, 1, 0, 0, 1): lambda x, y, z, w, v: (x, y, self.RxAntennaTemp(x, y, 290, v), 290, v),\n                (1, 0, 0, 1, 1): lambda x, y, z, w, v: (x, 0.0, self.RxAntennaTemp(x, 0.0, w, v), w, v),\n                (0, 0, 1, 1, 1): lambda x, y, z, w, v: (self.SystemNoiseTemp(0.0, z, w, v), 0.0, z, w, v),\n                (0, 1, 0, 1, 1): lambda x, y, z, w, v: (None, y, None, w, v),\n                (0, 1, 1, 0, 1): lambda x, y, z, w, v: (None, y, z, None, v),\n                (0, 1, 1, 1, 0): lambda x, y, z, w, v: (None, y, z, w, None),\n                (1, 0, 1, 0, 1): lambda x, y, z, w, v: (x, self.RxFilterLoss(x, z, 290, v), z, 290, v),\n                (1, 0, 1, 1, 0): lambda x, y, z, w, v: (x, 0.0, z, w, self.RxLNANoiseTemp2(x, 0.0, z, w)),\n                (1, 1, 0, 1, 0): lambda x, y, z, w, v: (x, y, None, w, None),\n\n                (0, 1, 1, 1, 1): lambda x, y, z, w, v: (self.SystemNoiseTemp(y, z, w, v), y, z, w, v),\n                (1, 0, 1, 1, 1): lambda x, y, z, w, v: (x, self.RxFilterLoss(x, z, w, v), z, w, v),\n                (1, 1, 0, 1, 1): lambda x, y, z, w, v: (x, y, self.RxAntennaTemp(x, y, w, v), w, v),\n                (1, 1, 1, 0, 1): lambda x, y, z, w, v: (x, y, z, self.RxOpTemp(x, y, z, v), v),\n                (1, 1, 1, 1, 0): lambda x, y, z, w, v: (x, y, z, w, self.RxLNANoiseTemp2(x, y, z, w)),\n                (1, 1, 1, 1, 1): lambda x, y, z, w, v: (x, y, z, w, v),\n            }\n            (rxSystemNoiseTemp, rxFilterLoss, rxAntennaTemp, rxOpTemp, rxLNANoiseTemp) = functions[pattern](\n                rxSystemNoiseTemp, rxFilterLoss, rxAntennaTemp, rxOpTemp, rxLNANoiseTemp)\n\n        except:\n            (rxSystemNoiseTemp, rxFilterLoss, rxAntennaTemp, rxOpTemp, rxLNANoiseTemp) = (\n                \"ERR:UB\", \"ERR:UB\", \"ERR:UB\",  \"ERR:UB\",  \"ERR:UB\")\n\n        return (rxSystemNoiseTemp, rxFilterLoss, rxAntennaTemp, rxOpTemp, rxLNANoiseTemp)\n\n    def RxGT_interaction(self, rxGT, rxGain, rxPointingLoss, rxFilterLoss, rxSystemNoiseTemp):\n      # HANDLING: ineraction between rxG/T, rxAntennaGain, rxPointingLoss, rxSystemNoiseTemp\n        try:\n            t_rxGT = 1 if type(rxGT) is float else 0\n            t_rxGain = 1 if type(rxGain) is float else 0\n            t_rxPointingLoss = 1 if type(rxPointingLoss) is float else 0\n            t_rxFilterLoss = 1 if type(rxFilterLoss) is float else 0\n            t_rxSystemNoiseTemp = 1 if type(rxSystemNoiseTemp) is float else 0\n\n            pattern = (t_rxGT, t_rxGain, t_rxPointingLoss,\n                       t_rxFilterLoss, t_rxSystemNoiseTemp)\n            functions = {\n                (0, 0, 0, 0, 0): lambda x, y, z, w, v: (None, None, None, None, None),\n                (0, 0, 0, 0, 1): lambda x, y, z, w, v: (None, None, None, None, v),\n                (0, 0, 0, 1, 0): lambda x, y, z, w, v: (None, None, None, w, None),\n                (0, 0, 1, 0, 0): lambda x, y, z, w, v: (None, None, z, None, None),\n                (0, 1, 0, 0, 0): lambda x, y, z, w, v: (None, y, None, None, None),\n                (1, 0, 0, 0, 0): lambda x, y, z, w, v: (x, None, None, None, None),\n\n                # assume pointing loss is 0 (for G/T) if none provided\n                # assume 0.0 db for feeder loss\n                (0, 0, 0, 1, 1): lambda x, y, z, w, v: (None, None, None, w, v),\n                (0, 0, 1, 1, 0): lambda x, y, z, w, v: (None, None, z, w, None),\n                (0, 1, 1, 0, 0): lambda x, y, z, w, v: (None, y, z, None, None),\n                (1, 1, 0, 0, 0): lambda x, y, z, w, v: (x, y, 0, 0.0, self.SystemNoiseTemp2(x, y, 0, 0.0)),\n                (1, 0, 1, 0, 0): lambda x, y, z, w, v: (x, None, z, None, None),\n                (1, 0, 0, 1, 0): lambda x, y, z, w, v: (x, None, None, w, None),\n                (1, 0, 0, 0, 1): lambda x, y, z, w, v: (x, self.RxAntennaGain2(x, 0, 0.0, v), 0, 0.0, v),\n                (0, 1, 0, 1, 0): lambda x, y, z, w, v: (None, y, None, w, None),\n                (0, 1, 0, 0, 1): lambda x, y, z, w, v: (self.RxGT(y, 0, 0.0, v), y, 0, 0.0, v),\n                (0, 0, 1, 0, 1): lambda x, y, z, w, v: (None, None, z, None, v),\n\n                # assume pointing loss is 0 (for G/T) if none provided\n                # assume 0.0 db for feeder loss\n                (1, 1, 1, 0, 0): lambda x, y, z, w, v: (x, y, z, 0.0, self.SystemNoiseTemp2(x, y, z, 0.0)),\n                (1, 1, 0, 0, 1): lambda x, y, z, w, v: (x, y, 0, self.RxFilterLoss2(x, y, 0, v), v),\n                (1, 0, 0, 1, 1): lambda x, y, z, w, v: (x, self.RxAntennaGain2(x, 0, w, v), 0, w, v),\n                (0, 0, 1, 1, 1): lambda x, y, z, w, v: (None, None, z, w, v),\n                (0, 1, 0, 1, 1): lambda x, y, z, w, v: (self.RxGT(y, 0, w, v), y, 0, w, v),\n                (0, 1, 1, 0, 1): lambda x, y, z, w, v: (self.RxGT(y, z, 0.0, v), y, z, 0.0, v),\n                (0, 1, 1, 1, 0): lambda x, y, z, w, v: (None, y, z, w, None),\n                (1, 0, 1, 0, 1): lambda x, y, z, w, v: (x, self.RxAntennaGain2(x, z, 0.0, v), z, 0.0, v),\n                (1, 0, 1, 1, 0): lambda x, y, z, w, v: (x, None, z, w, None),\n                (1, 1, 0, 1, 0): lambda x, y, z, w, v: (x, y, 0, w, self.SystemNoiseTemp2(x, y, 0, w)),\n\n                (0, 1, 1, 1, 1): lambda x, y, z, w, v: (self.RxGT(y, z, w, v), y, z, w, v),\n                (1, 0, 1, 1, 1): lambda x, y, z, w, v: (x, self.RxAntennaGain2(x, z, w, v), z, w, v),\n                (1, 1, 0, 1, 1): lambda x, y, z, w, v: (x, y, self.RxPointingLoss2(x, y, w, v), w, v),\n                (1, 1, 1, 0, 1): lambda x, y, z, w, v: (x, y, z, self.RxFilterLoss2(x, y, z, v), v),\n                (1, 1, 1, 1, 0): lambda x, y, z, w, v: (x, y, z, w, self.SystemNoiseTemp2(x, y, z, w)),\n                (1, 1, 1, 1, 1): lambda x, y, z, w, v: (x, y, z, w, v),\n            }\n\n            (rxGT, rxGain, rxPointingLoss, rxFilterLoss, rxSystemNoiseTemp) = functions[pattern](\n                rxGT, rxGain, rxPointingLoss, rxFilterLoss, rxSystemNoiseTemp)\n        except:\n            (rxGT, rxGain, rxPointingLoss, rxSystemNoiseTemp) = (\n                \"ERR:UB\", \"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (rxGT, rxGain, rxPointingLoss, rxFilterLoss, rxSystemNoiseTemp)\n\n    def runReceiver(self, parameters: dict):\n        wavelength = parameters[\"System\"][\"Wavelength\"].value\n        rxDiameter = parameters[\"Rx\"][\"Rx Antenna Diameter\"].value\n        rxPointingError = parameters[\"Rx\"][\"Rx Pointing Error\"].value\n        rxEfficiency = parameters[\"Rx\"][\"Rx Antenna Efficiency\"].value\n        rxLNANoiseFigure = parameters[\"Rx\"][\"Rx LNA Noise Figure\"].value\n        rxAntennaTemp = parameters[\"Rx\"][\"Rx Antenna Temperature\"].value\n        rxFilterLoss = parameters[\"Rx\"][\"Rx Feed and Input Filter Loss\"].value\n        rxOpTemp = parameters[\"Rx\"][\"Rx Feed Operating Temperature\"].value\n        rxLNANoiseTemp = parameters[\"Rx\"][\"Rx LNA Noise Effective Temperature\"].value\n\n        rxBeamwidth = parameters[\"Rx\"][\"Rx Beamwidth\"].value\n        rxPointingLoss = parameters[\"Rx\"][\"Rx Pointing Loss\"].value\n        rxGain = parameters[\"Rx\"][\"Rx Antenna Gain\"].value\n        rxSystemNoiseTemp = parameters[\"Rx\"][\"Rx System Noise Temperature\"].value\n        rxGT = parameters[\"Rx\"][\"Rx G/T\"].value\n        rxNoiseFactor = parameters[\"Rx\"][\"Rx Noise Factor\"].value\n\n        rxNoiseFactor, rxLNANoiseFigure = self.rxNoiseFactor_interaction(\n            rxNoiseFactor, rxLNANoiseFigure)\n        rxBeamwidth, rxDiameter, wavelength = self.RxBeamwidth_interaction(\n            rxBeamwidth, rxDiameter, wavelength)\n        rxGain, rxEfficiency, rxDiameter, wavelength = self.RxAntennaGain_interaction(\n            rxGain, rxEfficiency, rxDiameter, wavelength)\n        rxPointingLoss, rxPointingError, rxBeamwidth = self.RxPointingLoss_interaction(\n            rxPointingLoss, rxPointingError, rxBeamwidth)\n        rxLNANoiseTemp, rxLNANoiseFigure = self.RxLNANoiseTemp_interaction(\n            rxLNANoiseTemp, rxLNANoiseFigure)\n        rxSystemNoiseTemp, rxFilterLoss, rxAntennaTemp, rxOpTemp, rxLNANoiseTemp = self.SystemNoiseTemp_interaction(\n            rxSystemNoiseTemp, rxFilterLoss, rxAntennaTemp, rxOpTemp, rxLNANoiseTemp)\n        rxGT, rxGain, rxPointingLoss, rxFilterLoss, rxSystemNoiseTemp = self.RxGT_interaction(\n            rxGT, rxGain, rxPointingLoss, rxFilterLoss, rxSystemNoiseTemp)\n\n        parameters[\"Rx\"][\"Rx Antenna Efficiency\"].value = rxEfficiency\n        parameters[\"Rx\"][\"Rx Antenna Diameter\"].value = rxDiameter\n        parameters[\"Rx\"][\"Rx Beamwidth\"].value = rxBeamwidth\n        parameters[\"Rx\"][\"Rx Pointing Error\"].value = rxPointingError\n        parameters[\"Rx\"][\"Rx LNA Noise Effective Temperature\"].value = rxLNANoiseTemp\n        parameters[\"Rx\"][\"Rx LNA Noise Figure\"].value = rxLNANoiseFigure\n        parameters[\"Rx\"][\"Rx System Noise Temperature\"].value = rxSystemNoiseTemp\n        parameters[\"Rx\"][\"Rx Noise Factor\"].value = rxNoiseFactor\n        parameters[\"Rx\"][\"Rx Antenna Temperature\"].value = rxAntennaTemp\n        parameters[\"Rx\"][\"Rx Feed and Input Filter Loss\"].value = rxFilterLoss\n        parameters[\"Rx\"][\"Rx Feed Operating Temperature\"].value = rxOpTemp\n        parameters[\"Rx\"][\"Rx G/T\"].value = rxGT\n        parameters[\"Rx\"][\"Rx Antenna Gain\"].value = rxGain\n        parameters[\"Rx\"][\"Rx Pointing Loss\"].value = rxPointingLoss\n", "type": "text"}, {"name": "Equation_Files/System_Equations.py", "content": "import Equation_Files.Equation_Constants as Constants\nimport math\nimport copy as cp\n\n\ndef sec_to_hms(seconds):\n    \"\"\"\n    Converts seconds into the format hours:minutes:seconds.\n\n    Args:\n        seconds: A float representing the time in seconds.\n\n    Returns:\n        A string representing the time in hours:minutes:seconds.\n    \"\"\"\n\n    hour = int(seconds // 3600)\n    seconds %= 3600\n    minutes = int(seconds // 60)\n    seconds = round(seconds % 60, 1)\n    return str(hour)+\":\"+str(minutes)+\":\"+str(seconds)\n\n\ndef hms_to_sec(hms):\n    \"\"\"\n    Converts hours:minutes:seconds into seconds.\n\n    Args:\n        hms: A str representing the time in hours:minutes:seconds.\n\n    Returns:\n        A float representing the time in seconds.\n    \"\"\"\n    hour, minutes, seconds = hms.split(\":\", 2)\n    return float(hour)*3600 + float(minutes)*60 + float(seconds)\n\n\nclass Calculate_System():\n    \"\"\"\n    This class runs all the necessary calculations for the system tab.\n    \"\"\"\n    # the following functions are the functions that perform the equations for each parameter\n    # Some parameters can be calculated in multiple ways. Therefore, some parameters have\n    # multiple functions all labeled with *****1, ****2, etc.\n\n    # ----- Calculation Functions -----#\n\n    def orbitalRadius(self, altitude):\n        orbitalRadius = (altitude + Constants.r_E) * 1000  # meters\n        return orbitalRadius\n\n    def orbitalRadius2(self, orbitalSpeed):\n        orbitalRadius = Constants.M_earth * \\\n            Constants.G/(math.pow(orbitalSpeed*1000, 2))\n        return orbitalRadius\n\n    def orbitalRadius3(self, orbitalPeriod):\n        orbitalRadius = math.pow((math.pow(hms_to_sec(\n            orbitalPeriod)/(2*math.pi), 2)*Constants.M_earth*Constants.G), (1/3))\n        return orbitalRadius\n\n    def altitude(self, orbitalRadius):\n        altitude = (orbitalRadius / 1000) - Constants.r_E\n        return altitude\n\n    def orbitalSpeed(self, orbitalRadius):\n        orbitalSpeed = math.sqrt(\n            Constants.M_earth * Constants.G / orbitalRadius) / 1000  # km/sec\n        return orbitalSpeed\n\n    def orbitalPeriod(self, orbitalRadius):\n        orbitalPeriod = sec_to_hms(\n            2*math.pi*math.sqrt(math.pow(orbitalRadius, 3)/(Constants.M_earth*Constants.G)))\n        return orbitalPeriod\n\n    def wavelength(self, frequency):\n        wavelength = Constants.c/(frequency * 1e9)\n        return wavelength\n\n    def frequency(self, wavelength):\n        frequency = Constants.c/(wavelength * 1e9)\n        return frequency\n\n    # --------------------------------------#\n\n    # The following functions deal with each of the interactions between parameters.\n    # For example, the function named \"orbitalRadius_interaction\" deals with\n    # orbital radius and the parameters needed to calculate it. In these functions, some\n    # of the other equation functions are called. These functions are for parameters that\n    # can be backcalculated using the original equation. For example, you can calculate\n    # orbital radius from altitude, but can also calculate altitude from orbital radius.\n\n    # ----- Logic Group Functions -----#\n\n    def orbitalRadius_interaction(self, altitude, orbitalRadius):\n        # HANDLING: interaction between altitude and orbital radius\n        try:\n            t_altitude = 1 if type(altitude) is float else 0\n            t_orbitalRadius = 1 if type(orbitalRadius) is float else 0\n            pattern = (t_altitude, t_orbitalRadius)\n\n            functions = {\n                # performs calculations when possible, otherwise\n                # sets the parameter's value to None\n                (0, 0): lambda x, y: (None, None),\n                (0, 1): lambda x, y: (self.altitude(y), y),\n                (1, 0): lambda x, y: (x, self.orbitalRadius(x)),\n                (1, 1): lambda x, y: (x, y)\n            }\n\n            (altitude, orbitalRadius) = functions[pattern](\n                altitude, orbitalRadius)\n        except:\n            (altitude, orbitalRadius) = (\"ERR:UB\", \"ERR:UB\")\n\n        return (altitude, orbitalRadius)\n\n    def wavelength_interaction(self, frequency, wavelength):\n        # HANDLING: interaction between frequency and wavelength\n        try:\n            t_frequency = 1 if type(frequency) is float else 0\n            t_wavelength = 1 if type(wavelength) is float else 0\n            pattern = (t_frequency, t_wavelength)\n\n            functions = {\n                (0, 0): lambda x, y: (None, None),\n                (0, 1): lambda x, y: (self.frequency(y), y),\n                (1, 0): lambda x, y: (x, self.wavelength(x)),\n                (1, 1): lambda x, y: (x, y)\n            }\n\n            (frequency, wavelength) = functions[pattern](frequency, wavelength)\n\n        except:\n            (frequency, wavelength) = (\"ERR:UB\", \"ERR:UB\")\n\n        return (frequency, wavelength)\n\n    def orbitalSpeed_interaction(self, orbitalRadius, orbitalSpeed):\n        # HANDLING: interaction between orbital speed and orbital radius\n        try:\n            t_orbitalRadius = 1 if type(orbitalRadius) is float else 0\n            t_orbitalSpeed = 1 if type(orbitalSpeed) is float else 0\n            pattern = (t_orbitalRadius, t_orbitalSpeed)\n\n            functions = {\n                (0, 0): lambda x, y: (None, None),\n                (0, 1): lambda x, y: (self.orbitalRadius2(y), y),\n                (1, 0): lambda x, y: (x, self.orbitalSpeed(x)),\n                (1, 1): lambda x, y: (x, y)\n            }\n\n            (orbitalRadius, orbitalSpeed) = functions[pattern](\n                orbitalRadius, orbitalSpeed)\n\n        except:\n            (orbitalRadius, orbitalSpeed) = (\"ERR:UB\", \"ERR:UB\")\n\n        return (orbitalRadius, orbitalSpeed)\n\n    def orbitalPeriod_interaction(self, orbitalRadius, orbitalPeriod):\n\n        # HANDLING: interaction between orbital speed and orbital period\n        try:\n            t_orbitalRadius = 1 if type(orbitalRadius) is float else 0\n            t_orbitalPeriod = 1 if orbitalPeriod.count(\":\") == 2 else 0\n            pattern = (t_orbitalRadius, t_orbitalPeriod)\n\n            functions = {\n                (0, 0): lambda x, y: (None, None),\n                (0, 1): lambda x, y: (self.orbitalRadius3(y), y),\n                (1, 0): lambda x, y: (x, self.orbitalPeriod(x)),\n                (1, 1): lambda x, y: (x, y)\n            }\n            (orbitalRadius, orbitalPeriod) = functions[pattern](\n                orbitalRadius, orbitalPeriod)\n\n        except:\n            (orbitalRadius, orbitalPeriod) = (\"ERR:UB\", \"ERR:UB\")\n\n        return (orbitalRadius, orbitalPeriod)\n\n    # --------------------------------------#\n\n    # ----- Run System Equations -----#\n\n    def runSystem(self, parameters: dict):\n        \"\"\"\n        Runs through all the equations in the system tab calculating parameters\n        based on the availability of the parameters needed.\n        \"\"\"\n\n        # initialize values for the system tab\n        altitude = parameters[\"System\"][\"Altitude\"].value\n        orbitalRadius = parameters[\"System\"][\"Orbital Radius\"].value\n        frequency = parameters[\"System\"][\"Frequency\"].value\n        wavelength = parameters[\"System\"][\"Wavelength\"].value\n        orbitalSpeed = parameters[\"System\"][\"Orbital Speed\"].value\n        orbitalPeriod = parameters[\"System\"][\"Orbital Period\"].value\n\n        # loop through until consistent result\n        altitude, orbitalRadius = self.orbitalRadius_interaction(\n            altitude, orbitalRadius)\n        orbitalRadius, orbitalSpeed = self.orbitalSpeed_interaction(\n            orbitalRadius, orbitalSpeed)\n        orbitalRadius, orbitalPeriod = self.orbitalPeriod_interaction(\n            orbitalRadius, orbitalPeriod)\n        frequency, wavelength = self.wavelength_interaction(\n            frequency, wavelength)\n\n        # returns the values so the GUI displays the correct value\n        # for each parameter in the system tab\n        parameters[\"System\"][\"Orbital Period\"].value = orbitalPeriod\n        parameters[\"System\"][\"Altitude\"].value = altitude\n        parameters[\"System\"][\"Orbital Radius\"].value = orbitalRadius\n        parameters[\"System\"][\"Frequency\"].value = frequency\n        parameters[\"System\"][\"Wavelength\"].value = wavelength\n        parameters[\"System\"][\"Orbital Speed\"].value = orbitalSpeed\n", "type": "text"}, {"name": "Equation_Files/Transmitter_Equations.py", "content": "import math\n\n\nclass Calculate_Transmitter():\n\n    # ----- Calculation Functions -----#\n\n    def RFPowerDBW(self, txPAoutW):\n        # use dB for rest of calculations\n        txPAoutDBW = 10*math.log10(txPAoutW)\n        return txPAoutDBW\n\n    def RFPowerDBW3(self, txNPR, iTxNPR):\n        # backtracked from NPRInterference\n        txPAoutDBW = iTxNPR + txNPR\n        return txPAoutDBW\n\n    def RFPowerDBW4(self, txXPI, iTxXPI):\n        # backtracked from XPIInterference\n        txPAoutDBW = iTxXPI + txXPI\n        return txPAoutDBW\n\n    def RFPowerW(self, txPAoutDBW):\n        # backtracked from RFPowerDBW\n        txPAoutW = (math.pow(10, txPAoutDBW/10))\n        return txPAoutW\n\n    def NPRInterference(self, txPAoutDBW, txNPR):\n        iTxNPR = txPAoutDBW - txNPR\n        return iTxNPR\n\n    def NPR(self, txPAoutDBW, iTxNPR):\n        # backtracked from NPRInterference\n        txNPR = txPAoutDBW-iTxNPR\n        return txNPR\n\n    def XPIInterference(self, txPAoutDBW, txXPI):\n        iTxXPI = txPAoutDBW - txXPI\n        return iTxXPI\n\n    def XPI(self, txPAoutDBW, iTxXPI):\n        txXPI = txPAoutDBW - iTxXPI\n        return txXPI\n\n    def TxAntennaGain(self, wavelength, txDiameter, txEfficiency):\n        txGain = 10*math.log10(txEfficiency) + 20 * \\\n            math.log10((math.pi*txDiameter)/wavelength)\n        return txGain\n\n    def TxEfficiency(self, wavelength, txDiameter, txGain):\n        # backtracked from TxAntennaGain\n        txEfficiency = (math.pow(wavelength, 2)*math.pow(10, txGain/10)\n                        )/(math.pow(math.pi, 2)*math.pow(txDiameter, 2))\n        return txEfficiency\n\n    def TxBeamwidth(self, wavelength, txDiameter):\n        tx3beam = 70 * wavelength / txDiameter\n        return tx3beam\n\n    def TxBeamwidth2(self, altitude, txFootprintRadius):\n        tx3beam = math.atan(txFootprintRadius/altitude)*360/(math.pi)\n        return tx3beam\n\n    def TxBeamwidth3(self, txPointingError, txPointingLoss):\n        # backtracked from tx pointing loss\n        # make sure that the demoninator is not zero\n        if (math.pow(txPointingLoss/12, 1/2) != 0):\n            tx3beam = txPointingError/math.pow(txPointingLoss/12, 1/2)\n            return tx3beam\n        else:\n            return None\n\n    def TxDiameter(self, wavelength, tx3beam):\n        # backtracked from TxBeamwidth\n        txDiameter = 70 * wavelength / tx3beam\n        return txDiameter\n\n    def TxDiameter2(self, wavelength, txEfficiency, txGain):\n        # backtracked from TxAntennaGain\n        txDiameter = math.pow(\n            10, (txGain - 10*math.log10(txEfficiency))/20)*wavelength/math.pi\n        return txDiameter\n\n    def TxPointingLoss(self, tx3beam, txPointingError):\n        txPointingLoss = 12*math.pow(txPointingError/tx3beam, 2)\n        return txPointingLoss\n\n    def TxPointingError(self, tx3beam, txPointingLoss):\n        # backtracked from TxPointingLoss\n        txPointingError = math.sqrt(txPointingLoss/12)*tx3beam\n        return txPointingError\n\n    def EIRP2(self, txERP):\n        # backtracked from ERP\n        txEIRP = txERP + 2.15\n        return txEIRP\n\n    def ERP(self, txEIRP):\n        txERP = txEIRP - 2.15\n        return txERP\n\n    def FootprintRadius(self, altitude, tx3beam):\n        txFootprintRadius = altitude * \\\n            math.tan((math.pi / 180) * (tx3beam / 2))\n        return txFootprintRadius\n\n    # ----- Logic Group Functions -----#\n\n    def TXBeamwidth_Interaction(self, wavelength, txDiameter, tx3beam):\n        # HANDLING: interaction between 3 db Beamwidth, antenna diameter, and wavelength\n        try:\n            t_wavelength = 1 if type(wavelength) is float else 0\n            t_txDiameter = 1 if type(txDiameter) is float else 0\n            t_tx3beam = 1 if type(tx3beam) is float else 0\n            pattern = (t_wavelength, t_txDiameter, t_tx3beam)\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 1, 1): lambda x, y, z: (None, y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.TxBeamwidth(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, self.TxDiameter(x, z), z),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n\n            }\n\n            (wavelength, txDiameter, tx3beam) = functions[pattern](\n                wavelength, txDiameter, tx3beam)\n        except:\n            (wavelength, txDiameter, tx3beam) = (\"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (wavelength, txDiameter, tx3beam)\n\n    def FootprintRadius_interaction(self, altitude, tx3beam, txFootprintRadius):\n        # HANDLING: interaction between 3 db Beamwidth and 3 db footprint radius\n        try:\n            t_altitude = 1 if type(altitude) is float else 0\n            t_tx3beam = 1 if type(tx3beam) is float else 0\n            t_txFootprintRadius = 1 if type(txFootprintRadius) is float else 0\n            pattern = (t_altitude, t_tx3beam, t_txFootprintRadius)\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 1, 1): lambda x, y, z: (None, y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.FootprintRadius(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, self.TxBeamwidth2(x, z), z),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n\n            }\n\n            (altitude, tx3beam, txFootprintRadius) = functions[pattern](\n                altitude, tx3beam, txFootprintRadius)\n\n        except:\n            (altitude, tx3beam, txFootprintRadius) = (\n                \"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n        return (altitude, tx3beam, txFootprintRadius)\n\n    def TxAntennaGain_interaction(self, wavelength, txDiameter, txEfficiency, txGain):\n        # HANDLING: interaction between Tx Antenna Diameter, Tx Antenna Efficiency, and Tx Antenna Gain\n        try:\n\n            t_wavelength = 1 if type(wavelength) is float else 0\n            t_txDiameter = 1 if type(txDiameter) is float else 0\n            t_txEfficiency = 1 if type(txEfficiency) is float else 0\n            t_txGain = 1 if type(txGain) is float else 0\n            pattern = (t_wavelength, t_txDiameter, t_txEfficiency, t_txGain)\n            functions = {\n\n                (0, 0, 0, 0): lambda x, y, z, w: (None, None, None, None),\n                (0, 0, 0, 1): lambda x, y, z, w: (None, None, None, w),\n                (0, 0, 1, 0): lambda x, y, z, w: (None, None, z, None),\n                (0, 1, 0, 0): lambda x, y, z, w: (None, y, None, None),\n                (1, 0, 0, 0): lambda x, y, z, w: (x, None, None, None),\n                (1, 1, 0, 0): lambda x, y, z, w: (x, y, 0.65, self.TxAntennaGain(x, y, 0.65)),\n                (0, 1, 1, 0): lambda x, y, z, w: (None, y, z, None),\n                (0, 0, 1, 1): lambda x, y, z, w: (None, None, z, w),\n                (1, 0, 0, 1): lambda x, y, z, w: (x, self.TxDiameter2(x, 0.65, w), 0.65, w),\n                (1, 0, 1, 0): lambda x, y, z, w: (x, None, z, None),\n                (0, 1, 0, 1): lambda x, y, z, w: (None, y, None, w),\n                (0, 1, 1, 1): lambda x, y, z, w: (None, y, z, w),\n                (1, 0, 1, 1): lambda x, y, z, w: (x, self.TxDiameter2(x, z, w), z, w),\n                (1, 1, 0, 1): lambda x, y, z, w: (x, y, self.TxEfficiency(x, y, w), w),\n                (1, 1, 1, 0): lambda x, y, z, w: (x, y, z, self.TxAntennaGain(x, y, z)),\n                (1, 1, 1, 1): lambda x, y, z, w: (x, y, z, w)\n            }\n\n            (wavelength, txDiameter, txEfficiency, txGain) = functions[pattern](\n                wavelength, txDiameter, txEfficiency, txGain)\n\n        except:\n            (wavelength, txDiameter, txEfficiency, txGain) = (\n                \"ERR:UB\", \"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (wavelength, txDiameter, txEfficiency, txGain)\n\n    def TxPointingLoss_interaction(self, tx3beam, txPointingError, txPointingLoss):\n        # HANDLING: interaction between 3 db Beamwidth, Pointing Error, and Tx Pointing Loss\n        # try:\n        t_tx3beam = 1 if type(tx3beam) is float else 0\n        t_txPointingError = 1 if type(txPointingError) is float else 0\n        t_txPointingLoss = 1 if type(txPointingLoss) is float else 0\n        pattern = (t_tx3beam, t_txPointingError, t_txPointingLoss)\n        functions = {\n            # if no pointing error, assume 0 for pointing loss\n            (0, 0, 0): lambda x, y, z: (None, None, 0.0),\n            (0, 1, 1): lambda x, y, z: (self.TxBeamwidth3(y, z), y, z),\n            (1, 1, 0): lambda x, y, z: (x, y, self.TxPointingLoss(x, y)),\n            (1, 0, 1): lambda x, y, z: (x, self.TxPointingError(x, z), z),\n            (1, 0, 0): lambda x, y, z: (x, None, 0.0),\n            (0, 1, 0): lambda x, y, z: (None, y, None),\n            (0, 0, 1): lambda x, y, z: (None, None, z),\n            (1, 1, 1): lambda x, y, z: (x, y, z)\n        }\n\n        (tx3beam, txPointingError, txPointingLoss) = functions[pattern](\n            tx3beam, txPointingError, txPointingLoss)\n\n        # except:\n        #    (tx3beam, txPointingError, txPointingLoss) = (\"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (tx3beam, txPointingError, txPointingLoss)\n\n    def RFPowerDBW_interaction(self, txPAoutW, txPAoutDBW):\n        # HANDLING: interaction between Power Amp RF Ouput (W) and Power Amp RF Ouput (dbW)\n        try:\n            t_txPAoutW = 1 if type(txPAoutW) is float else 0\n            t_txPAoutDBW = 1 if type(txPAoutDBW) is float else 0\n            pattern = (t_txPAoutW, t_txPAoutDBW)\n\n            functions = {\n                (0, 0): lambda x, y: (None, None),\n                (0, 1): lambda x, y: (self.RFPowerW(y), y),\n                (1, 0): lambda x, y: (x, self.RFPowerDBW(x)),\n                (1, 1): lambda x, y: (x, y)\n            }\n\n            (txPAoutW, txPAoutDBW) = functions[pattern](txPAoutW, txPAoutDBW)\n\n        except:\n            (txPAoutW, txPAoutDBW) = (\"ERR:UB\", \"ERR:UB\")\n\n        return (txPAoutW, txPAoutDBW)\n\n    def EIRP_interaction(self, txGain, txPointingLoss, txFeederLoss, polarizationMismatch, txPAoutDBW, txEIRP):\n        # HANDLING: interaction between gain, pointing loss, feeder loss, power amp RF output (DBW), polarization mismatch, and EIRP\n\n        inputs = [txGain, txPointingLoss, txFeederLoss,\n                  polarizationMismatch, txPAoutDBW, txEIRP]\n\n        # Build a boolean bitmap of whether each input is valid or not\n        pattern = [type(n) is float for n in inputs]\n\n        # txEIRP = txGain - txPointingLoss - txFeederLoss - polarizationMismatch + txPAoutDBW, therefore,\n        # 0 = txGain - txPointingLoss - txFeederLoss - polarizationMismatch + txPAoutDBW - txEIRP\n        #  - When one of these parameters is unknown, the sum of this expression is NOT zero.\n        signs = (1, -1, -1, -1, 1, -1)\n        # Build a parameters array with correct signage for the second equation that has 0.0 subbed in for unknowns\n        parameters = [0.0 if not pattern[i] else inputs[i]*signs[i]\n                      for i in range(0, len(inputs))]\n\n        # CASE 1 -- We have 6 inputs; just in case the input EIRP is wrong, let's recalculate it\n        if sum(pattern) == 6:\n            txEIRP = sum(parameters[:5])\n            output = [txGain, txPointingLoss, txFeederLoss,\n                      polarizationMismatch, txPAoutDBW, txEIRP]\n\n        # CASE 2 -- We have 5 known values; the sum of the array tells us the 6th\n        elif sum(pattern) == 5:\n            # Sum the array\n            solution = sum(parameters)\n            # If txGain or txPAoutDBW is what's missing, the solution has a flipped sign\n            if not pattern[0] or not pattern[4]:\n                solution *= -1\n            # Build an output list that has the solution inserted into the unknown position\n            output = [inputs[i] if pattern[i]\n                      else solution for i in range(0, len(inputs))]\n\n        # CASE 3 -- We know txGain and txPAoutdBW but NOT EIRP; we can calculate EIRP by assuming zeroes for unknown losses\n        elif pattern[0] and pattern[4] and not pattern[5]:\n            txEIRP = sum(parameters[:5])\n            # Build an output list that preserves the zero assumptions and prevents -0.0's from appearing\n            output = [-parameters[i] if (i >= 1 and i <= 3 and parameters[i] != 0.0)\n                      else parameters[i] for i in range(0, len(parameters)-1)]\n            output.append(txEIRP)\n\n        # CASE 4 -- We know EIRP but we're missing multiple losses; we can't differentiate how the parameter sum\n        # is split amongst those losses.  (There's no back-calculation we can do with fewer than 5 parameters)\n        else:\n            output = [inputs[i] if pattern[i]\n                      else '--' for i in range(0, len(inputs))]\n\n        # Remove -0.0's\n        output = [output[i] if output[i] !=\n                  0.0 else 0.0 for i in range(0, len(output))]\n        return tuple(output)\n\n    def txERP_interaction(self, txEIRP, txERP):\n        # HANDLING: interaction between EIRP and ERP\n        try:\n            t_txEIRP = 1 if type(txEIRP) is float else 0\n            t_txERP = 1 if type(txERP) is float else 0\n            pattern = (t_txEIRP, t_txERP)\n\n            functions = {\n                (0, 0): lambda x, y: (None, None),\n                (0, 1): lambda x, y: (self.EIRP2(y), y),\n                (1, 0): lambda x, y: (x, self.ERP(x)),\n                (1, 1): lambda x, y: (x, y)\n            }\n            (txEIRP, txERP) = functions[pattern](txEIRP, txERP)\n\n        except:\n            (txEIRP, txERP) = (\"ERR:UB\", \"ERR:UB\")\n\n        return (txEIRP, txERP)\n\n    def iTxNPR_interaction(self, txPAoutDBW, txNPR, iTxNPR):\n        # HANDLING: interaction between Tx Noise Power Ratio and I-Tx NPR\n        try:\n            t_txPAoutDBW = 1 if type(txPAoutDBW) is float else 0\n            t_txNPR = 1 if type(txNPR) is float else 0\n            t_iTxNPR = 1 if type(iTxNPR) is float else 0\n            pattern = (t_txPAoutDBW, t_txNPR, t_iTxNPR)\n\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 1, 1): lambda x, y, z: (self.RFPowerDBW3(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.NPRInterference(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, self.NPR(x, z), z),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n            }\n\n            (txPAoutDBW, txNPR, iTxNPR) = functions[pattern](\n                txPAoutDBW, txNPR, iTxNPR)\n\n        except:\n            (txPAoutDBW, txNPR, iTxNPR) = (\"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (txPAoutDBW, txNPR, iTxNPR)\n\n    def iTxXPI_interaction(self, txPAoutDBW, txXPI, iTxXPI):\n        # HANDLING: interaction between Tx Cross-Pol Isolation and I - Tx XPI\n        try:\n            t_txPAoutDBW = 1 if type(txPAoutDBW) is float else 0\n            t_txXPI = 1 if type(txXPI) is float else 0\n            t_iTxXPI = 1 if type(iTxXPI) is float else 0\n            pattern = (t_txPAoutDBW, t_txXPI, t_iTxXPI)\n\n            functions = {\n                (0, 0, 0): lambda x, y, z: (None, None, None),\n                (0, 1, 1): lambda x, y, z: (self.RFPowerDBW4(y, z), y, z),\n                (1, 1, 0): lambda x, y, z: (x, y, self.XPIInterference(x, y)),\n                (1, 0, 1): lambda x, y, z: (x, self.XPI(x, z), z),\n                (1, 0, 0): lambda x, y, z: (x, None, None),\n                (0, 1, 0): lambda x, y, z: (None, y, None),\n                (0, 0, 1): lambda x, y, z: (None, None, z),\n                (1, 1, 1): lambda x, y, z: (x, y, z)\n            }\n\n            (txPAoutDBW, txXPI, iTxXPI) = functions[pattern](\n                txPAoutDBW, txXPI, iTxXPI)\n\n        except:\n            (txPAoutDBW, txXPI, iTxXPI) = (\"ERR:UB\", \"ERR:UB\", \"ERR:UB\")\n\n        return (txPAoutDBW, txXPI, iTxXPI)\n\n    def runTransmitter(self, parameters: dict):\n        wavelength = parameters[\"System\"][\"Wavelength\"].value\n        txDiameter = parameters[\"Tx\"][\"Tx Antenna Diameter\"].value\n        tx3beam = parameters[\"Tx\"][\"3 dB Beamwidth\"].value\n        txFootprintRadius = parameters[\"Tx\"][\"3 dB Footprint Radius\"].value\n        altitude = parameters[\"System\"][\"Altitude\"].value\n        txEfficiency = parameters[\"Tx\"][\"Tx Antenna Efficiency\"].value\n        txGain = parameters[\"Tx\"][\"Tx Antenna Gain\"].value\n        txPointingError = parameters[\"Tx\"][\"Pointing Error\"].value\n        txPointingLoss = parameters[\"Tx\"][\"Tx Pointing Loss\"].value\n        txPAoutW = parameters[\"Tx\"][\"Power Amp RF Output (W)\"].value\n        txPAoutDBW = parameters[\"Tx\"][\"Power Amp RF Output (dBW)\"].value\n        txFeederLoss = parameters[\"Tx\"][\"Feeder (Insertion) Loss\"].value\n        polarizationMismatch = parameters[\"Tx\"][\"Polarization Mismatch\"].value\n        txEIRP = parameters[\"Tx\"][\"Tx EIRP\"].value\n        txERP = parameters[\"Tx\"][\"Tx ERP\"].value\n        # txXPI = parameters[\"Tx\"][\"Tx Cross-Pol Isolation (XPI)\"].value\n        # iTxXPI = parameters[\"Tx\"][\"I - Tx XPI\"].value\n        # iTxNPR = parameters[\"Tx\"][\"I - Tx NPR\"].value\n        # txNPR = parameters[\"Tx\"][\"Tx Noise Power Ratio\"].value\n\n        wavelength, txDiameter, tx3beam = self.TXBeamwidth_Interaction(\n            wavelength, txDiameter, tx3beam)\n        altitude, tx3beam, txFootprintRadius = self. FootprintRadius_interaction(\n            altitude, tx3beam, txFootprintRadius)\n        wavelength, txDiameter, txEfficiency, txGain = self.TxAntennaGain_interaction(\n            wavelength, txDiameter, txEfficiency, txGain)\n        tx3beam, txPointingError, txPointingLoss = self.TxPointingLoss_interaction(\n            tx3beam, txPointingError, txPointingLoss)\n        txPAoutW, txPAoutDBW = self.RFPowerDBW_interaction(\n            txPAoutW, txPAoutDBW)\n        # txPAoutDBW, txNPR, iTxNPR = self.iTxNPR_interaction(\n        #     txPAoutDBW, txNPR, iTxNPR)\n        # txPAoutDBW, txXPI, iTxXPI = self.iTxXPI_interaction(\n        #     txPAoutDBW, txXPI, iTxXPI)\n        txGain, txPointingLoss, txFeederLoss, polarizationMismatch, txPAoutDBW, txEIRP = self.EIRP_interaction(\n            txGain, txPointingLoss, txFeederLoss, polarizationMismatch, txPAoutDBW, txEIRP)\n        txEIRP, txERP = self.txERP_interaction(txEIRP, txERP)\n\n        parameters[\"Tx\"][\"3 dB Beamwidth\"].value = tx3beam\n        parameters[\"Tx\"][\"Tx Antenna Diameter\"].value = txDiameter\n        parameters[\"Tx\"][\"3 dB Footprint Radius\"].value = txFootprintRadius\n        parameters[\"Tx\"][\"Tx Antenna Gain\"].value = txGain\n        parameters[\"Tx\"][\"Tx Antenna Efficiency\"].value = txEfficiency\n        parameters[\"Tx\"][\"Tx Pointing Loss\"].value = txPointingLoss\n        parameters[\"Tx\"][\"Pointing Error\"].value = txPointingError\n        parameters[\"Tx\"][\"Power Amp RF Output (dBW)\"].value = txPAoutDBW\n        parameters[\"Tx\"][\"Power Amp RF Output (W)\"].value = txPAoutW\n        parameters[\"Tx\"][\"Tx EIRP\"].value = txEIRP\n        parameters[\"Tx\"][\"Feeder (Insertion) Loss\"].value = txFeederLoss\n        parameters[\"Tx\"][\"Polarization Mismatch\"].value = polarizationMismatch\n        parameters[\"Tx\"][\"Tx ERP\"].value = txERP\n        # parameters[\"Tx\"][\"I - Tx NPR\"].value = iTxNPR\n        # parameters[\"Tx\"][\"Tx Noise Power Ratio\"].value = txNPR\n        # parameters[\"Tx\"][\"Tx Cross-Pol Isolation (XPI)\"].value = txXPI\n        # parameters[\"Tx\"][\"I - Tx XPI\"].value = iTxXPI\n", "type": "text"}]